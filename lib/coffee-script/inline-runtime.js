/**
 * IcedCoffeeScript Compiler v112.8.1 (based on CoffeeScript v1.12.8).
 *
 * http://iced-coffee-script.github.io/iced-coffee-script
 *
 * Copyright 2011-2019, Jeremy Ashkenas, Maxwell Krohn, Micha≈Ç Zochniak
 * Released under the MIT License
 */
(function() {
  function require(path){ return require[path]; }
  require['./const'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    k: "__iced_k",
    k_noop: "__iced_k_noop",
    param: "__iced_p_",
    ns: "iced",
    runtime: "runtime",
    Deferrals: "Deferrals",
    deferrals: "__iced_deferrals",
    fulfill: "_fulfill",
    b_while: "_break",
    t_while: "_while",
    c_while: "_continue",
    n_while: "_next",
    n_arg: "__iced_next_arg",
    defer_method: "defer",
    slot: "__slot",
    assign_fn: "assign_fn",
    autocb: "autocb",
    retslot: "ret",
    trace: "__iced_trace",
    passed_deferral: "__iced_passed_deferral",
    findDeferral: "findDeferral",
    lineno: "lineno",
    parent: "parent",
    filename: "filename",
    funcname: "funcname",
    catchExceptions: 'catchExceptions',
    runtime_modes: ["node", "inline", "window", "none", "browserify", "interp"],
    trampoline: "trampoline",
    context: "context",
    defer_arg: "__iced_defer_",
    iterator: "__iced_it",
    await_exit: "await_exit"
  };

}).call(this);

  return module.exports;
})();
require['./runtime'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by IcedCoffeeScript 1.10.0
(function() {
  var C, Deferrals, Rendezvous, __active_trace, __c, _trace_to_string, exceptionHandler, findDeferral, make_defer_return, stackWalk, tick_counter, trampoline, warn,
    slice = [].slice;

  C = require('./const');

  make_defer_return = function(obj, defer_args, id, trace_template, multi) {
    var k, ret, trace, v;
    trace = {};
    for (k in trace_template) {
      v = trace_template[k];
      trace[k] = v;
    }
    trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;
    ret = function() {
      var inner_args, o, ref;
      inner_args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (defer_args != null) {
        if ((ref = defer_args.assign_fn) != null) {
          ref.apply(null, inner_args);
        }
      }
      if (obj) {
        o = obj;
        if (!multi) {
          obj = null;
        }
        return o._fulfill(id, trace);
      } else {
        return warn("overused deferral at " + (_trace_to_string(trace)));
      }
    };
    ret[C.trace] = trace;
    return ret;
  };

  __c = 0;

  tick_counter = function(mod) {
    __c++;
    if ((__c % mod) === 0) {
      __c = 0;
      return true;
    } else {
      return false;
    }
  };

  __active_trace = null;

  _trace_to_string = function(tr) {
    var fn;
    fn = tr[C.funcname] || "<anonymous>";
    return fn + " (" + tr[C.filename] + ":" + (tr[C.lineno] + 1) + ")";
  };

  warn = function(m) {
    return typeof console !== "undefined" && console !== null ? console.error("ICED warning: " + m) : void 0;
  };

  exports.trampoline = trampoline = function(fn) {
    if (!tick_counter(500)) {
      return fn();
    } else if ((typeof process !== "undefined" && process !== null ? process.nextTick : void 0) != null) {
      return process.nextTick(fn);
    } else {
      return setTimeout(fn);
    }
  };

  exports.Deferrals = Deferrals = (function() {
    function Deferrals(iterator, trace1) {
      this.iterator = iterator;
      this.trace = trace1;
      this.count = 1;
      this.ret = null;
      this.yielded = false;
    }

    Deferrals.prototype._call = function(trace) {
      var i;
      if (this.iterator) {
        __active_trace = trace;
        i = this.iterator;
        this.iterator = null;
        if (this.yielded) {
          return i.next(this.ret);
        }
      } else {
        return warn("Entered dead await at " + (_trace_to_string(trace)));
      }
    };

    Deferrals.prototype._fulfill = function(id, trace) {
      if (--this.count <= 0) {
        return this._call(trace);
      }
    };

    Deferrals.prototype.await_exit = function() {
      this._fulfill();
      if (this.count === 0) {
        this.iterator = null;
        return false;
      } else {
        this.yielded = true;
        return true;
      }
    };

    Deferrals.prototype.defer = function(args) {
      var self;
      this.count++;
      self = this;
      return make_defer_return(self, args, null, this.trace);
    };

    return Deferrals;

  })();

  exports.findDeferral = findDeferral = function(args) {
    var a, j, len;
    for (j = 0, len = args.length; j < len; j++) {
      a = args[j];
      if (a != null ? a[C.trace] : void 0) {
        return a;
      }
    }
    return null;
  };

  exports.Rendezvous = Rendezvous = (function() {
    var RvId;

    function Rendezvous() {
      this.completed = [];
      this.waiters = [];
      this.defer_id = 0;
    }

    RvId = (function() {
      function RvId(rv, id1, multi1) {
        this.rv = rv;
        this.id = id1;
        this.multi = multi1;
      }

      RvId.prototype.defer = function(defer_args) {
        return this.rv._defer_with_id(this.id, defer_args, this.multi);
      };

      return RvId;

    })();

    Rendezvous.prototype.wait = function(cb) {
      var x;
      if (this.completed.length) {
        x = this.completed.shift();
        return cb(x);
      } else {
        return this.waiters.push(cb);
      }
    };

    Rendezvous.prototype.defer = function(defer_args) {
      var id;
      id = this.defer_id++;
      return this._defer_with_id(id, defer_args);
    };

    Rendezvous.prototype.id = function(i, multi) {
      multi = !!multi;
      return new RvId(this, i, multi);
    };

    Rendezvous.prototype._fulfill = function(id, trace) {
      var cb;
      if (this.waiters.length) {
        cb = this.waiters.shift();
        return cb(id);
      } else {
        return this.completed.push(id);
      }
    };

    Rendezvous.prototype._defer_with_id = function(id, defer_args, multi) {
      this.count++;
      return make_defer_return(this, defer_args, id, {}, multi);
    };

    return Rendezvous;

  })();

  exports.stackWalk = stackWalk = function(cb) {
    var line, ref, ret, tr;
    ret = [];
    tr = cb ? cb[C.trace] : __active_trace;
    while (tr) {
      line = "   at " + (_trace_to_string(tr));
      ret.push(line);
      tr = tr != null ? (ref = tr[C.parent]) != null ? ref[C.trace] : void 0 : void 0;
    }
    return ret;
  };

  exports.exceptionHandler = exceptionHandler = function(err, logger) {
    var stack;
    if (!logger) {
      logger = console.error;
    }
    logger(err.stack);
    stack = stackWalk();
    if (stack.length) {
      logger("Iced 'stack' trace (w/ real line numbers):");
      return logger(stack.join("\n"));
    }
  };

  exports.catchExceptions = function(logger) {
    return typeof process !== "undefined" && process !== null ? process.on('uncaughtException', function(err) {
      exceptionHandler(err, logger);
      return process.exit(1);
    }) : void 0;
  };

}).call(this);

  return module.exports;
})();
require['./library'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  var C, Pipeliner, _iand, _ior, _timeout, iced,
    slice = [].slice;



  C = require('./const');

  exports.iced = iced = require('./runtime');

  _timeout = function(cb, t, res, tmp) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var arr, rv, which;
      return function*() {
        var __iced_deferrals;
        rv = new iced.Rendezvous;
        tmp[0] = rv.id(true).defer({
          assign_fn: (function() {
            return function() {
              return arr = slice.call(arguments, 0);
            };
          })(),
          lineno: 20,
          context: __iced_deferrals
        });
        setTimeout(rv.id(false).defer({
          lineno: 21,
          context: __iced_deferrals
        }), t);
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral
        });
        rv.wait(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return which = arguments[0];
            };
          })(),
          lineno: 22
        }));
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        if (res) {
          res[0] = which;
        }
        return cb.apply(null, arr);
      };
    })(this)();
    return __iced_it.next();
  };

  exports.timeout = function(cb, t, res) {
    var tmp;
    tmp = [];
    _timeout(cb, t, res, tmp);
    return tmp[0];
  };

  _iand = function(cb, res, tmp) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var ok;
      return function*() {
        var __iced_deferrals;
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 39
        });
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        if (!ok) {
          res[0] = false;
        }
        return cb();
      };
    })(this)();
    return __iced_it.next();
  };

  exports.iand = function(cb, res) {
    var tmp;
    tmp = [];
    _iand(cb, res, tmp);
    return tmp[0];
  };

  _ior = function(cb, res, tmp) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var ok;
      return function*() {
        var __iced_deferrals;
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 58
        });
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        if (ok) {
          res[0] = true;
        }
        return cb();
      };
    })(this)();
    return __iced_it.next();
  };

  exports.ior = function(cb, res) {
    var tmp;
    tmp = [];
    _ior(cb, res, tmp);
    return tmp[0];
  };

  exports.Pipeliner = Pipeliner = (function() {
    function Pipeliner(window, delay) {
      this.window = window || 1;
      this.delay = delay || 0;
      this.queue = [];
      this.n_out = 0;
      this.cb = null;
      this[C.deferrals] = this;
      this["defer"] = this._defer;
    }

    Pipeliner.prototype.waitInQueue = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          while (_this.n_out >= _this.window) {
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Pipeliner.waitInQueue"
            });
            _this.cb = __iced_deferrals.defer({
              lineno: 100
            });
            if (__iced_deferrals.await_exit()) {
              yield;
            }
          }
          _this.n_out++;
          if (_this.delay) {
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Pipeliner.waitInQueue"
            });
            setTimeout(__iced_deferrals1.defer({
              lineno: 108
            }), _this.delay);
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
          }
          return cb();
        };
      })(this)();
      return __iced_it.next();
    };

    Pipeliner.prototype.__defer = function(out, deferArgs) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var tmp, voidCb;
        return function*() {
          var __iced_deferrals;
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Pipeliner.__defer"
          });
          voidCb = __iced_deferrals.defer({
            lineno: 122
          });
          out[0] = function() {
            var args, ref;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            if ((ref = deferArgs.assign_fn) != null) {
              ref.apply(null, args);
            }
            return voidCb();
          };
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          _this.n_out--;
          if (_this.cb) {
            tmp = _this.cb;
            _this.cb = null;
            return tmp();
          }
        };
      })(this)();
      return __iced_it.next();
    };

    Pipeliner.prototype._defer = function(deferArgs) {
      var tmp;
      tmp = [];
      this.__defer(tmp, deferArgs);
      return tmp[0];
    };

    Pipeliner.prototype.flush = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        return function*() {
          var __iced_deferrals;
          while (_this.n_out) {
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Pipeliner.flush"
            });
            _this.cb = __iced_deferrals.defer({
              lineno: 151
            });
            if (__iced_deferrals.await_exit()) {
              yield;
            }
          }
          return cb();
        };
      })(this)();
      return __iced_it.next();
    };

    return Pipeliner;

  })();

}).call(this);

  return module.exports;
})();
require['./main'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  var i, k, len, mod, mods, v;

  exports["const"] = require('./const');

  mods = [require('./runtime'), require('./library')];

  for (i = 0, len = mods.length; i < len; i++) {
    mod = mods[i];
    for (k in mod) {
      v = mod[k];
      exports[k] = v;
    }
  }

}).call(this);

  return module.exports;
})();

  return require['./main'];
}());
