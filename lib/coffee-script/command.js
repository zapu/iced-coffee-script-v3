// Generated by IcedCoffeeScript 112.8.0
// The `coffee` utility. Handles command-line compilation of CoffeeScript
// into various forms: saved into `.js` files or printed to stdout
// or recompiled every time the source is saved,
// printed as a token stream or as the syntax tree, or launch an
// interactive REPL.
// External dependencies.
(function() {
  var EventEmitter, exec, ref, spawn,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  let fs = require('fs');

  let path = require('path');

  let helpers = require('./helpers');

  let optparse = require('./optparse');

  let CoffeeScript = require('./coffee-script');

  ref = require('child_process'), spawn = ref.spawn, exec = ref.exec;

  EventEmitter = require('events').EventEmitter;

  let iced = require('iced-runtime-3');

  // Iced addition
  let runtime_modes_str = "{" + (iced["const"].runtime_modes.join(", ")) + "}";

  let useWinPathSep = path.sep === '\\';

  // Allow CoffeeScript to emit Node.js events.
  helpers.extend(CoffeeScript, new EventEmitter);

  let printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  let printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

  let hidden = function(file) {
    return /^\.|~$/.test(file);
  };

  // The help banner that is printed in conjunction with `-h`/`--help`.
  let BANNER = 'Usage: coffee [options] path/to/script.coffee -- [args]\n\nIf called without options, `coffee` will run your script.';

  // The list of all the valid option flags that `coffee` knows how to handle.
  let SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive CoffeeScript REPL'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-m', '--map', 'generate source map and save as .js.map files'], ['-M', '--inline-map', 'generate source map and include it directly in output'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['--nodejs [ARGS]', 'pass options directly to the "node" binary'], ['--no-header', 'suppress the "Generated by" header'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-r', '--require [MODULE*]', 'require the given module before eval or REPL'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-l', '--literate', 'treat stdio as literate style coffee-script'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands'],  /* Iced additions */ ['-I', '--runtime [WHICH]', "how to include the iced runtime, one of " + runtime_modes_str + "; default is 'node'"], ['-F', '--runforce', 'output an Iced runtime even if not needed']];

  // Top-level objects shared by all the functions.
  let opts = {};

  let sources = [];

  let sourceCode = [];

  let notSources = {};

  let watchedDirs = {};

  let optionParser = null;

  // Run `coffee` by parsing passed options and determining what action to take.
  // Many flags cause us to divert before compiling anything. Flags passed after
  // `--` will be passed verbatim to your script as arguments in `process.argv`
  exports.run = function() {
    var i, len, ref1, results, source;
    parseOptions();
    // Make the REPL *CLI* use the global context so as to (a) be consistent with the
    // `node` REPL CLI and, therefore, (b) make packages that modify native prototypes
    // (such as 'colors' and 'sugar') work as expected.
    let replCliOpts = {
      useGlobal: true
    };
    if (opts.require) {
      opts.prelude = makePrelude(opts.require);
    }
    replCliOpts.prelude = opts.prelude;
    if (opts.nodejs) {
      return forkNode();
    }
    if (opts.help) {
      return usage();
    }
    if (opts.version) {
      return version();
    }
    if (opts.interactive) {
      return require('./repl').start(replCliOpts);
    }
    if (opts.stdio) {
      return compileStdio();
    }
    if (opts["eval"]) {
      return compileScript(null, opts["arguments"][0]);
    }
    if (!opts["arguments"].length) {
      return require('./repl').start(replCliOpts);
    }
    let literals = opts.run ? opts["arguments"].splice(1) : [];
    process.argv = process.argv.slice(0, 2).concat(literals);
    process.argv[0] = 'coffee';
    if (opts.output) {
      opts.output = path.resolve(opts.output);
    }
    if (opts.join) {
      opts.join = path.resolve(opts.join);
      console.error('\nThe --join option is deprecated and will be removed in a future version.\n\nIf for some reason it\'s necessary to share local variables between files,\nreplace...\n\n    $ coffee --compile --join bundle.js -- a.coffee b.coffee c.coffee\n\nwith...\n\n    $ cat a.coffee b.coffee c.coffee | coffee --compile --stdio > bundle.js\n');
    }
    ref1 = opts["arguments"];
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      source = ref1[i];
      source = path.resolve(source);
      results.push(compilePath(source, true, source));
    }
    return results;
  };

  let makePrelude = function(requires) {
    return requires.map(function(module) {
      var _, match, name;
      if (match = module.match(/^(.*)=(.*)$/)) {
        _ = match[0], name = match[1], module = match[2];
      }
      name || (name = helpers.baseFileName(module, true, useWinPathSep));
      return name + " = require('" + module + "')";
    }).join(';');
  };

  // Compile a path, which could be a script or a directory. If a directory
  // is passed, recursively compile all '.coffee', '.litcoffee', and '.coffee.md'
  // extension source files in it and all subdirectories.
  let compilePath = function(source, topLevel, base) {
    var code, err, file, files, i, len, results, stats;
    if (indexOf.call(sources, source) >= 0 || watchedDirs[source] || !topLevel && (notSources[source] || hidden(source))) {
      return;
    }
    try {
      stats = fs.statSync(source);
    } catch (error) {
      err = error;
      if (err.code === 'ENOENT') {
        console.error("File not found: " + source);
        process.exit(1);
      }
      throw err;
    }
    if (stats.isDirectory()) {
      if (path.basename(source) === 'node_modules') {
        notSources[source] = true;
        return;
      }
      if (opts.run) {
        compilePath(findDirectoryIndex(source), topLevel, base);
        return;
      }
      if (opts.watch) {
        watchDir(source, base);
      }
      try {
        files = fs.readdirSync(source);
      } catch (error) {
        err = error;
        if (err.code === 'ENOENT') {
          return;
        } else {
          throw err;
        }
      }
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        results.push(compilePath(path.join(source, file), false, base));
      }
      return results;
    } else if (topLevel || helpers.isCoffee(source)) {
      sources.push(source);
      sourceCode.push(null);
      delete notSources[source];
      if (opts.watch) {
        watch(source, base);
      }
      try {
        code = fs.readFileSync(source);
      } catch (error) {
        err = error;
        if (err.code === 'ENOENT') {
          return;
        } else {
          throw err;
        }
      }
      return compileScript(source, code.toString(), base);
    } else {
      return notSources[source] = true;
    }
  };

  let findDirectoryIndex = function(source) {
    var err, ext, i, len, ref1;
    ref1 = CoffeeScript.FILE_EXTENSIONS;
    for (i = 0, len = ref1.length; i < len; i++) {
      ext = ref1[i];
      let index = path.join(source, "index" + ext);
      try {
        if ((fs.statSync(index)).isFile()) {
          return index;
        }
      } catch (error) {
        err = error;
        if (err.code !== 'ENOENT') {
          throw err;
        }
      }
    }
    console.error("Missing index.coffee or index.litcoffee in " + source);
    return process.exit(1);
  };

  // Compile a single source script, containing the given code, according to the
  // requested options. If evaluating the script directly sets `__filename`,
  // `__dirname` and `module.filename` to be correct relative to the script's path.
  let compileScript = function(file, input, base) {
    var err, task;
    if (base == null) {
      base = null;
    }
    let o = opts;
    let options = compileOptions(file, base);
    try {
      let t = task = {
        file: file,
        input: input,
        options: options
      };
      CoffeeScript.emit('compile', task);
      if (o.tokens) {
        return printTokens(CoffeeScript.tokens(t.input, t.options));
      } else if (o.nodes) {
        return printLine(CoffeeScript.nodes(t.input, t.options).toString().trim());
      } else if (o.run) {
        CoffeeScript.register();
        if (opts.prelude) {
          CoffeeScript["eval"](opts.prelude, t.options);
        }
        return CoffeeScript.run(t.input, t.options);
      } else if (o.join && t.file !== o.join) {
        if (helpers.isLiterate(file)) {
          t.input = helpers.invertLiterate(t.input);
        }
        sourceCode[sources.indexOf(t.file)] = t.input;
        return compileJoin();
      } else {
        let compiled = CoffeeScript.compile(t.input, t.options);
        t.output = compiled;
        if (o.map) {
          t.output = compiled.js;
          t.sourceMap = compiled.v3SourceMap;
        }
        CoffeeScript.emit('success', task);
        if (o.print) {
          return printLine(t.output.trim());
        } else if (o.compile || o.map) {
          return writeJs(base, t.file, t.output, options.jsPath, t.sourceMap);
        }
      }
    } catch (error) {
      err = error;
      CoffeeScript.emit('failure', err, task);
      if (CoffeeScript.listeners('failure').length) {
        return;
      }
      let message = (err != null ? err.stack : void 0) || ("" + err);
      if (o.watch) {
        return printLine(message + '\x07');
      } else {
        printWarn(message);
        return process.exit(1);
      }
    }
  };

  // Attach the appropriate listeners to compile scripts incoming over **stdin**,
  // and write them back to **stdout**.
  let compileStdio = function() {
    let buffers = [];
    let stdin = process.openStdin();
    stdin.on('data', function(buffer) {
      if (buffer) {
        return buffers.push(buffer);
      }
    });
    return stdin.on('end', function() {
      return compileScript(null, Buffer.concat(buffers).toString());
    });
  };

  // If all of the source files are done being read, concatenate and compile
  // them together.
  let joinTimeout = null;

  let compileJoin = function() {
    if (!opts.join) {
      return;
    }
    if (!sourceCode.some(function(code) {
      return code === null;
    })) {
      clearTimeout(joinTimeout);
      return joinTimeout = wait(100, function() {
        return compileScript(opts.join, sourceCode.join('\n'), opts.join);
      });
    }
  };

  // Watch a source CoffeeScript file using `fs.watch`, recompiling it every
  // time the file is updated. May be used in combination with other options,
  // such as `--print`.
  let watch = function(source, base) {
    var err;
    let watcher = null;
    let prevStats = null;
    let compileTimeout = null;
    let watchErr = function(err) {
      if (err.code !== 'ENOENT') {
        throw err;
      }
      if (indexOf.call(sources, source) < 0) {
        return;
      }
      try {
        rewatch();
        return compile();
      } catch (error) {
        removeSource(source, base);
        return compileJoin();
      }
    };
    let compile = function() {
      clearTimeout(compileTimeout);
      return compileTimeout = wait(25, function() {
        return fs.stat(source, function(err, stats) {
          if (err) {
            return watchErr(err);
          }
          if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
            return rewatch();
          }
          prevStats = stats;
          return fs.readFile(source, function(err, code) {
            if (err) {
              return watchErr(err);
            }
            compileScript(source, code.toString(), base);
            return rewatch();
          });
        });
      });
    };
    let startWatcher = function() {
      return watcher = fs.watch(source).on('change', compile).on('error', function(err) {
        if (err.code !== 'EPERM') {
          throw err;
        }
        return removeSource(source, base);
      });
    };
    let rewatch = function() {
      if (watcher != null) {
        watcher.close();
      }
      return startWatcher();
    };
    try {
      return startWatcher();
    } catch (error) {
      err = error;
      return watchErr(err);
    }
  };

  // Watch a directory of files for new additions.
  let watchDir = function(source, base) {
    var err;
    let watcher = null;
    let readdirTimeout = null;
    let startWatcher = function() {
      return watcher = fs.watch(source).on('error', function(err) {
        if (err.code !== 'EPERM') {
          throw err;
        }
        return stopWatcher();
      }).on('change', function() {
        clearTimeout(readdirTimeout);
        return readdirTimeout = wait(25, function() {
          var err, file, files, i, len, results;
          try {
            files = fs.readdirSync(source);
          } catch (error) {
            err = error;
            if (err.code !== 'ENOENT') {
              throw err;
            }
            return stopWatcher();
          }
          results = [];
          for (i = 0, len = files.length; i < len; i++) {
            file = files[i];
            results.push(compilePath(path.join(source, file), false, base));
          }
          return results;
        });
      });
    };
    let stopWatcher = function() {
      watcher.close();
      return removeSourceDir(source, base);
    };
    watchedDirs[source] = true;
    try {
      return startWatcher();
    } catch (error) {
      err = error;
      if (err.code !== 'ENOENT') {
        throw err;
      }
    }
  };

  let removeSourceDir = function(source, base) {
    var file, i, len;
    delete watchedDirs[source];
    let sourcesChanged = false;
    for (i = 0, len = sources.length; i < len; i++) {
      file = sources[i];
      if (!(source === path.dirname(file))) {
        continue;
      }
      removeSource(file, base);
      sourcesChanged = true;
    }
    if (sourcesChanged) {
      return compileJoin();
    }
  };

  // Remove a file from our source list, and source code cache. Optionally remove
  // the compiled JS version as well.
  let removeSource = function(source, base) {
    let index = sources.indexOf(source);
    sources.splice(index, 1);
    sourceCode.splice(index, 1);
    if (!opts.join) {
      silentUnlink(outputPath(source, base));
      silentUnlink(outputPath(source, base, '.js.map'));
      return timeLog("removed " + source);
    }
  };

  let silentUnlink = function(path) {
    var err, ref1;
    try {
      return fs.unlinkSync(path);
    } catch (error) {
      err = error;
      if ((ref1 = err.code) !== 'ENOENT' && ref1 !== 'EPERM') {
        throw err;
      }
    }
  };

  // Get the corresponding output JavaScript path for a source file.
  let outputPath = function(source, base, extension) {
    var dir;
    if (extension == null) {
      extension = ".js";
    }
    let basename = helpers.baseFileName(source, true, useWinPathSep);
    let srcDir = path.dirname(source);
    if (!opts.output) {
      dir = srcDir;
    } else if (source === base) {
      dir = opts.output;
    } else {
      dir = path.join(opts.output, path.relative(base, srcDir));
    }
    return path.join(dir, basename + extension);
  };

  // Recursively mkdir, like `mkdir -p`.
  let mkdirp = function(dir, fn) {
    var mkdirs;
    let mode = 0x1ff & ~process.umask();
    return (mkdirs = function(p, fn) {
      return fs.exists(p, function(exists) {
        if (exists) {
          return fn();
        } else {
          return mkdirs(path.dirname(p), function() {
            return fs.mkdir(p, mode, function(err) {
              if (err) {
                return fn(err);
              }
              return fn();
            });
          });
        }
      });
    })(dir, fn);
  };

  // Write out a JavaScript source file with the compiled code. By default, files
  // are written out in `cwd` as `.js` files with the same name, but the output
  // directory can be customized with `--output`.
  //
  // If `generatedSourceMap` is provided, this will write a `.js.map` file into the
  // same directory as the `.js` file.
  let writeJs = function(base, sourcePath, js, jsPath, generatedSourceMap) {
    if (generatedSourceMap == null) {
      generatedSourceMap = null;
    }
    let sourceMapPath = outputPath(sourcePath, base, ".js.map");
    let jsDir = path.dirname(jsPath);
    let compile = function() {
      if (opts.compile) {
        if (js.length <= 0) {
          js = ' ';
        }
        if (generatedSourceMap) {
          js = js + "\n//# sourceMappingURL=" + (helpers.baseFileName(sourceMapPath, false, useWinPathSep)) + "\n";
        }
        fs.writeFile(jsPath, js, function(err) {
          if (err) {
            printLine(err.message);
            return process.exit(1);
          } else if (opts.compile && opts.watch) {
            return timeLog("compiled " + sourcePath);
          }
        });
      }
      if (generatedSourceMap) {
        return fs.writeFile(sourceMapPath, generatedSourceMap, function(err) {
          if (err) {
            printLine("Could not write source map: " + err.message);
            return process.exit(1);
          }
        });
      }
    };
    return fs.exists(jsDir, function(itExists) {
      if (itExists) {
        return compile();
      } else {
        return mkdirp(jsDir, compile);
      }
    });
  };

  // Convenience for cleaner setTimeouts.
  let wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  // When watching scripts, it's useful to log changes with the timestamp.
  let timeLog = function(message) {
    return console.log(((new Date).toLocaleTimeString()) + " - " + message);
  };

  // Pretty-print a stream of tokens, sans location data.
  let printTokens = function(tokens) {
    var token;
    let strings = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        let tag = token[0];
        let value = token[1].toString().replace(/\n/g, '\\n');
        results.push("[" + tag + " " + value + "]");
      }
      return results;
    })();
    return printLine(strings.join(' '));
  };

  let handleIcedOptions = function(o) {
    // Some opts we can read out of the evironment
    var v, val;
    if (!o.runtime && ((v = process.env.ICED_RUNTIME) != null)) {
      o.runtime = v;
    }
    if (((val = o.runtime) != null) && indexOf.call(iced["const"].runtime_modes, val) < 0) {
      throw new Error("Option -I/--runtime has to be one of " + runtime_modes_str + ", got '" + val + "'");
    }
  };

  // Use the [OptionParser module](optparse.html) to extract all options from
  // `process.argv` that are specified in `SWITCHES`.
  let parseOptions = function() {
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    let o = opts = optionParser.parse(process.argv.slice(2));
    o.compile || (o.compile = !!o.output);
    o.run = !(o.compile || o.print || o.map);
    return o.print = !!(o.print || (o["eval"] || o.stdio && o.compile));
  };

  // The compile-time options to pass to the CoffeeScript compiler.
  let compileOptions = function(filename, base) {
    let answer = {
      filename: filename,
      literate: opts.literate || helpers.isLiterate(filename),
      bare: opts.bare,
      header: opts.compile && !opts['no-header'],
      sourceMap: opts.map,
      inlineMap: opts['inline-map'],
      // Iced additions:
      runtime: opts.runtime,
      runforce: opts.runforce
    };
    handleIcedOptions(answer);
    if (filename) {
      if (base) {
        let cwd = process.cwd();
        let jsPath = outputPath(filename, base);
        let jsDir = path.dirname(jsPath);
        answer = helpers.merge(answer, {
          jsPath: jsPath,
          sourceRoot: path.relative(jsDir, cwd),
          sourceFiles: [path.relative(cwd, filename)],
          generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep)
        });
      } else {
        answer = helpers.merge(answer, {
          sourceRoot: "",
          sourceFiles: [helpers.baseFileName(filename, false, useWinPathSep)],
          generatedFile: helpers.baseFileName(filename, true, useWinPathSep) + ".js"
        });
      }
    }
    return answer;
  };

  // Start up a new Node.js instance with the arguments in `--nodejs` passed to
  // the `node` binary, preserving the other options.
  let forkNode = function() {
    let nodeArgs = opts.nodejs.split(/\s+/);
    let args = process.argv.slice(1);
    args.splice(args.indexOf('--nodejs'), 2);
    let p = spawn(process.execPath, nodeArgs.concat(args), {
      cwd: process.cwd(),
      env: process.env,
      stdio: [0, 1, 2]
    });
    return p.on('exit', function(code) {
      return process.exit(code);
    });
  };

  // Print the `--help` usage message and exit. Deprecated switches are not
  // shown.
  let usage = function() {
    return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
  };

  // Print the `--version` message and exit.
  let version = function() {
    return printLine("IcedCoffeeScript version " + CoffeeScript.ICED_VERSION);
  };

}).call(this);
