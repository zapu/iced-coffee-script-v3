// Generated by IcedCoffeeScript 112.8.0
// CoffeeScript can be used both on the server, as a command-line compiler based
// on Node.js/V8, or to run CoffeeScript directly in the browser. This module
// contains the main entry functions for tokenizing, parsing, and compiling
// source CoffeeScript into JavaScript.
(function() {
  var Lexer, compile, ext, fn1, j, len, parser, ref,
    hasProp = {}.hasOwnProperty;

  let fs = require('fs');

  let vm = require('vm');

  let path = require('path');

  Lexer = require('./lexer').Lexer;

  parser = require('./parser').parser;

  let helpers = require('./helpers');

  let SourceMap = require('./sourcemap');

  // CoffeeScript (original) version which this iced patchset is based on.
  // CoffeeScript 1 is no longer being developed with exception of occasional
  // patches.
  exports.COFFEE_VERSION = '1.12.8';

  exports.VERSION = exports.COFFEE_VERSION;

  // IcedCoffeeScript version. We used to derive ICED_VERSION from COFFEE_VERSION
  // which Iced patched was based on, and Iced3 is consistent with that scheme.
  // The scheme is as following: `v[0] * 100 + v[1], v[2], ICED_PATCH_VERSION`
  exports.ICED_VERSION = '112.8.0';

  try {

  } catch (error) {}

  // If available, use version from package.json. Require `package.json`, which
  // is two levels above this file, as this file is typically evaluated from
  // `lib/coffee-script`.
  // TODO: UNDECIDED
  // packageJson   = require '../../package.json'
  // exports.VERSION = packageJson.version
  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md', '.iced', '.liticed', '.iced.md'];

  // Expose helpers for testing.
  exports.helpers = helpers;

  // Run through the "iced" transform process
  let icedTransform = function(x, options) {
    return x.icedTransform(options);
  };

  // Function that allows for btoa in both nodejs and the browser.
  let base64encode = function(src) {
    switch (false) {
      case typeof Buffer !== 'function':
        return Buffer.from(src).toString('base64');
      case typeof btoa !== 'function':
        // The contents of a `<script>` block are encoded via UTF-16, so if any extended
        // characters are used in the block, btoa will fail as it maxes out at UTF-8.
        // See https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
        // for the gory details, and for the solution implemented here.
        return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function(match, p1) {
          return String.fromCharCode('0x' + p1);
        }));
      default:
        throw new Error('Unable to base64 encode inline sourcemap.');
    }
  };

  // Function wrapper to add source file information to SyntaxErrors thrown by the
  // lexer/parser/compiler.
  let withPrettyErrors = function(fn) {
    return function(code, options) {
      var err;
      if (options == null) {
        options = {};
      }
      try {
        return fn.call(this, code, options);
      } catch (error) {
        err = error;
        if (typeof code !== 'string') {
          throw err;
        }
        // Support `CoffeeScript.nodes(tokens)`.
        throw helpers.updateSyntaxError(err, code, options.filename);
      }
    };
  };

  // For each compiled file, save its source in memory in case we need to
  // recompile it later. We might need to recompile if the first compilation
  // didn’t create a source map (faster) but something went wrong and we need
  // a stack trace. Assuming that most of the time, code isn’t throwing
  // exceptions, it’s probably more efficient to compile twice only when we
  // need a stack trace, rather than always generating a source map even when
  // it’s not likely to be used. Save in form of `filename`: `(source)`
  let sources = {};

  // Also save source maps if generated, in form of `filename`: `(source map)`.
  let sourceMaps = {};

  // Compile CoffeeScript code to JavaScript, using the Coffee/Jison compiler.
  //
  // If `options.sourceMap` is specified, then `options.filename` must also be
  // specified. All options that can be passed to `SourceMap#generate` may also
  // be passed here.
  //
  // This returns a javascript string, unless `options.sourceMap` is passed,
  // in which case this returns a `{js, v3SourceMap, sourceMap}`
  // object, where sourceMap is a sourcemap.coffee#SourceMap object, handy for
  // doing programmatic lookups.
  exports.compile = compile = withPrettyErrors(function(code, options) {
    var extend, fragment, j, l, len, len1, map, merge, ref, ref1, token, v3SourceMap;
    merge = helpers.merge, extend = helpers.extend;
    options = extend({}, options);
    // Always generate a source map if no filename is passed in, since without a
    // a filename we have no way to retrieve this source later in the event that
    // we need to recompile it to get a source map for `prepareStackTrace`.
    let generateSourceMap = options.sourceMap || options.inlineMap || (options.filename == null);
    let filename = options.filename || '<anonymous>';
    sources[filename] = code;
    if (generateSourceMap) {
      map = new SourceMap;
    }
    let tokens = lexer.tokenize(code, options);
    let comments = lexer.comments;
    //console.log 'Comments:',comments
    // Pass a list of referenced variables, so that generated variables won't get
    // the same name.
    options.referencedVars = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = tokens.length; j < len; j++) {
        token = tokens[j];
        if (token[0] === 'IDENTIFIER') {
          results.push(token[1]);
        }
      }
      return results;
    })();
    // Pass comments. Type-comments affect codegen. We also mark type-comments as
    // "used", so we can error out if there are any unused and therefore misplaced
    // type-comments.
    options.comments = comments;
    // Check for import or export; if found, force bare mode.
    if (!((options.bare != null) && options.bare === true)) {
      for (j = 0, len = tokens.length; j < len; j++) {
        token = tokens[j];
        if ((ref = token[0]) === 'IMPORT' || ref === 'EXPORT') {
          options.bare = true;
          break;
        }
      }
    }
    let fragments = icedTransform(parser.parse(tokens), options).compileToFragments(options);
    insertComments(fragments, options);
    let currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    let currentColumn = 0;
    let js = "";
    for (l = 0, len1 = fragments.length; l < len1; l++) {
      fragment = fragments[l];
      // Update the sourcemap with data from each fragment.
      if (generateSourceMap) {
        // Do not include empty, whitespace, or semicolon-only fragments.
        if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        let newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) {
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += fragment.code.length;
        }
      }
      // Copy the code from each fragment into the final JavaScript.
      js += fragment.code;
    }
    if (options.header) {
      let header = "Generated by IcedCoffeeScript " + this.ICED_VERSION;
      js = "// " + header + "\n" + js;
    }
    if (generateSourceMap) {
      v3SourceMap = map.generate(options, code);
      sourceMaps[filename] = map;
    }
    if (options.inlineMap) {
      let encoded = base64encode(JSON.stringify(v3SourceMap));
      let sourceMapDataURI = "//# sourceMappingURL=data:application/json;base64," + encoded;
      let sourceURL = "//# sourceURL=" + ((ref1 = options.filename) != null ? ref1 : 'coffeescript');
      js = js + "\n" + sourceMapDataURI + "\n" + sourceURL;
    }
    if (options.sourceMap) {
      return {
        js: js,
        sourceMap: map,
        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)
      };
    } else {
      return js;
    }
  });

  // Tokenize a string of CoffeeScript code, and return the array of tokens.
  exports.tokens = withPrettyErrors(function(code, options) {
    return lexer.tokenize(code, options);
  });

  // Parse a string of CoffeeScript code or an array of lexed tokens, and
  // return the AST. You can then compile it by calling `.compile()` on the root,
  // or traverse it by using `.traverseChildren()` with a callback.
  exports.nodes = withPrettyErrors(function(source, options) {
    let nodes = typeof source === 'string' ? parser.parse(lexer.tokenize(source, options)) : parser.parse(source);
    return icedTransform(nodes, options);
  });

  // Compile and execute a string of CoffeeScript (on the server), correctly
  // setting `__filename`, `__dirname`, and relative `require()`.
  exports.run = function(code, options) {
    var ref;
    if (options == null) {
      options = {};
    }
    let mainModule = require.main;
    // Set the filename.
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '<anonymous>';
    // Clear the module cache.
    mainModule.moduleCache && (mainModule.moduleCache = {});
    // Assign paths for node_modules loading
    let dir = options.filename != null ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
    mainModule.paths = require('module')._nodeModulePaths(dir);
    // Compile.
    if (!helpers.isCoffee(mainModule.filename) || require.extensions) {
      let answer = compile(code, options);
      code = (ref = answer.js) != null ? ref : answer;
    }
    return mainModule._compile(code, mainModule.filename);
  };

  // Compile and evaluate a string of CoffeeScript (in a Node.js-like environment).
  // The CoffeeScript REPL uses this to run the input.
  exports["eval"] = function(code, options) {
    var _module, _require, j, k, len, r, ref, ref1, ref2, ref3, sandbox, v;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    let createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;
    let isContext = (ref1 = vm.isContext) != null ? ref1 : function(ctx) {
      return options.sandbox instanceof createContext().constructor;
    };
    if (createContext) {
      if (options.sandbox != null) {
        if (isContext(options.sandbox)) {
          sandbox = options.sandbox;
        } else {
          sandbox = createContext();
          ref2 = options.sandbox;
          for (k in ref2) {
            if (!hasProp.call(ref2, k)) continue;
            v = ref2[k];
            sandbox[k] = v;
          }
        }
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
      } else {
        sandbox = global;
      }
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      // define module/require only if they chose not to specify their own
      if (!(sandbox !== global || sandbox.module || sandbox.require)) {
        let Module = require('module');
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function(path) {
          return Module._load(path, _module, true);
        };
        _module.filename = sandbox.__filename;
        ref3 = Object.getOwnPropertyNames(require);
        for (j = 0, len = ref3.length; j < len; j++) {
          r = ref3[j];
          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') {
            _require[r] = require[r];
          }
        }
        // use the same hack node currently uses for their own REPL
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function(request) {
          return Module._resolveFilename(request, _module);
        };
      }
    }
    let o = {};
    for (k in options) {
      if (!hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    // ensure return value
    let js = compile(code, o);
    if (sandbox === global) {
      return vm.runInThisContext(js);
    } else {
      return vm.runInContext(js, sandbox);
    }
  };

  exports.register = function() {
    return require('./register');
  };

  // Throw error with deprecation warning when depending upon implicit `require.extensions` registration
  if (require.extensions) {
    ref = this.FILE_EXTENSIONS;
    fn1 = function(ext) {
      var base;
      return (base = require.extensions)[ext] != null ? base[ext] : base[ext] = function() {
        throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require " + ext + " files.");
      };
    };
    for (j = 0, len = ref.length; j < len; j++) {
      ext = ref[j];
      fn1(ext);
    }
  }

  exports._compileFile = function(filename, sourceMap, inlineMap) {
    var answer, err;
    if (sourceMap == null) {
      sourceMap = false;
    }
    if (inlineMap == null) {
      inlineMap = false;
    }
    let raw = fs.readFileSync(filename, 'utf8');
    // Strip the Unicode byte order mark, if this file begins with one.
    let stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    try {
      answer = compile(stripped, {
        filename: filename,
        sourceMap: sourceMap,
        inlineMap: inlineMap,
        sourceFiles: [filename],
        literate: helpers.isLiterate(filename)
      });
    } catch (error) {
      // As the filename and code of a dynamically loaded file will be different
      // from the original file compiled with CoffeeScript.run, add that
      // information to error so it can be pretty-printed later.
      err = error;
      throw helpers.updateSyntaxError(err, stripped, filename);
    }
    return answer;
  };

  // Instantiate a Lexer for our use here.
  let lexer = new Lexer;

  // The real Lexer produces a generic stream of tokens. This object provides a
  // thin wrapper around it, compatible with the Jison API. We can then pass it
  // directly as a "Jison lexer".
  parser.lexer = {
    lex: function() {
      var tag;
      let token = parser.tokens[this.pos++];
      if (token) {
        tag = token[0], this.yytext = token[1], this.yylloc = token[2];
        parser.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function(tokens) {
      parser.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  // Make all the AST nodes visible to the parser.
  parser.yy = require('./nodes');

  // Override Jison's default error handling function.
  parser.yy.parseError = function(message, arg) {
    // Disregard Jison's message, it contains redundant line number information.
    // Disregard the token, we take its value directly from the lexer in case
    // the error is caused by a generated token which might refer to its origin.
    var errorLoc, errorTag, errorText, errorToken, token, tokens;
    token = arg.token;
    errorToken = parser.errorToken, tokens = parser.tokens;
    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];
    errorText = (function() {
      switch (false) {
        case errorToken !== tokens[tokens.length - 1]:
          return 'end of input';
        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':
          return 'indentation';
        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'INFINITY' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':
          return errorTag.replace(/_START$/, '').toLowerCase();
        default:
          return helpers.nameWhitespaceCharacter(errorText);
      }
    })();
    // The second argument has a `loc` property, which should have the location
    // data for this token. Unfortunately, Jison seems to send an outdated `loc`
    // (from the previous token), so we take the location information directly
    // from the lexer.
    return helpers.throwSyntaxError("unexpected " + errorText, errorLoc);
  };

  let insertComments = function(fragments, options) {
    var comments;
    comments = options.comments;
    let findIndent = function(start) {
      //console.log 'bt start', start, fragments[start]
      var i, l, ref1;
      if (start === 0) {
        return ['', 0, true, ''];
      }
      let m = fragments[start].code.match(/^(\s*)/);
      let indent = m[1];
      let postdent = '';
      for (i = l = ref1 = start - 1; ref1 <= 0 ? l <= 0 : l >= 0; i = ref1 <= 0 ? ++l : --l) {
        //console.log 'bting', i, fragments[i]
        switch (false) {
          case !(m = fragments[i].code.match(/\n(\s*)$/)):
            postdent += m[1];
            return [indent, i + 1, true, postdent];
          case !(m = fragments[i].code.match(/^\s*$/)):
            indent += m[0];
            continue;
          default:
            return [indent, i + 1, false, ''];
        }
      }
    };
    let startFragI = 0;
    return comments.forEach(function(comment) {
      var cLoc, canNewline, code, endOfLine, fullLine, i, indent, l, postdent, ref1, ref2, ref3;
      if (comment.jsdoc) {
        if (!comment.fullLine) {
          helpers.throwSyntaxError("JSDoc comment should span the entire line", comment.locationData);
        }
        if (!comment.jsdocConsumed) {
          helpers.throwSyntaxError("Unexpected JSDoc comment (not used by code-gen)", comment.locationData);
        } else {
          // Consumed by code-gen - already emitted in correct place by nodes.coffee.
          return;
        }
      }
      //console.log 'On Comm', comment
      fullLine = comment.fullLine, endOfLine = comment.endOfLine, cLoc = comment.locationData;
      for (i = l = ref1 = startFragI, ref2 = fragments.length; ref1 <= ref2 ? l < ref2 : l > ref2; i = ref1 <= ref2 ? ++l : --l) {
        let frag = fragments[i];
        //console.log i, frag
        let fragLoc = frag.locationData;
        if (fragLoc == null) {
          continue;
        }
        if (fragLoc.first_line > cLoc.first_line) {
          if (fullLine || endOfLine) {
            ref3 = findIndent(i), indent = ref3[0], i = ref3[1], canNewline = ref3[2], postdent = ref3[3];
            if (canNewline) {
              code = indent + "//" + comment.text + "\n" + postdent;
            } else {
              code = " /*" + comment.text + " */ ";
            }
            startFragI = i;
            fragments.splice(i, 0, {
              code: code,
              locationData: cLoc,
              type: 'Comment'
            });
            return;
          }
        }
      }
      // we are done with adding this comment
      // Couldn't find a fragment - must be end of file.
      if (fullLine || endOfLine) {
        code = "//" + comment.text;
        return fragments.push({
          code: code,
          locationData: cLoc
        });
      }
    });
  };

  // Based on http://v8.googlecode.com/svn/branches/bleeding_edge/src/messages.js
  // Modified to handle sourceMap
  let formatSourcePosition = function(frame, getSourceMapping) {
    var as;
    let filename = void 0;
    let fileLocation = '';
    if (frame.isNative()) {
      fileLocation = "native";
    } else {
      if (frame.isEval()) {
        filename = frame.getScriptNameOrSourceURL();
        if (!filename) {
          fileLocation = (frame.getEvalOrigin()) + ", ";
        }
      } else {
        filename = frame.getFileName();
      }
      filename || (filename = "<anonymous>");
      let line = frame.getLineNumber();
      let column = frame.getColumnNumber();
      // Check for a sourceMap position
      let source = getSourceMapping(filename, line, column);
      fileLocation = source ? filename + ":" + source[0] + ":" + source[1] : filename + ":" + line + ":" + column;
    }
    let functionName = frame.getFunctionName();
    let isConstructor = frame.isConstructor();
    let isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) {
      let methodName = frame.getMethodName();
      let typeName = frame.getTypeName();
      if (functionName) {
        let tp = as = '';
        if (typeName && functionName.indexOf(typeName)) {
          tp = typeName + ".";
        }
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          as = " [as " + methodName + "]";
        }
        return "" + tp + functionName + as + " (" + fileLocation + ")";
      } else {
        return typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
      }
    } else if (isConstructor) {
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
    } else if (functionName) {
      return functionName + " (" + fileLocation + ")";
    } else {
      return fileLocation;
    }
  };

  let getSourceMap = function(filename) {
    if (sourceMaps[filename] != null) {
      return sourceMaps[filename];
    } else  /* CoffeeScript compiled in a browser may get compiled with `options.filename` */  /* of `<anonymous>`, but the browser may request the stack trace with the */  /* filename of the script file. */ if (sourceMaps['<anonymous>'] != null) {
      return sourceMaps['<anonymous>'];
    } else if (sources[filename] != null) {
      let answer = compile(sources[filename], {
        filename: filename,
        sourceMap: true,
        literate: helpers.isLiterate(filename)
      });
      return answer.sourceMap;
    } else {
      return null;
    }
  };

  // Based on [michaelficarra/CoffeeScriptRedux](http://goo.gl/ZTx1p)
  // NodeJS / V8 have no support for transforming positions in stack traces using
  // sourceMap, so we must monkey-patch Error to display CoffeeScript source
  // positions.
  Error.prepareStackTrace = function(err, stack) {
    var frame;
    let getSourceMapping = function(filename, line, column) {
      var answer;
      let sourceMap = getSourceMap(filename);
      if (sourceMap != null) {
        answer = sourceMap.sourceLocation([line - 1, column - 1]);
      }
      if (answer != null) {
        return [answer[0] + 1, answer[1] + 1];
      } else {
        return null;
      }
    };
    let frames = (function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = stack.length; l < len1; l++) {
        frame = stack[l];
        if (frame.getFunction() === exports.run) {
          break;
        }
        results.push("    at " + (formatSourcePosition(frame, getSourceMapping)));
      }
      return results;
    })();
    return (err.toString()) + "\n" + (frames.join('\n')) + "\n";
  };

}).call(this);
