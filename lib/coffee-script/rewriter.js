// Generated by IcedCoffeeScript 112.8.0
// The CoffeeScript language has a good deal of optional syntax, implicit syntax,
// and shorthand syntax. This can greatly complicate a grammar and bloat
// the resulting parse table. Instead of making the parser handle it all, we take
// a series of passes over the token stream, using this **Rewriter** to convert
// shorthand into the unambiguous long form, add implicit indentation and
// parentheses, and generally clean things up.
// Create a generated token: one that exists due to a use of implicit syntax.
(function() {
  var INVERSES, Rewriter, k, left, len, ref, rite,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  let generate = function(tag, value, origin) {
    let tok = [tag, value];
    tok.generated = true;
    if (origin) {
      tok.origin = origin;
    }
    return tok;
  };

  // The **Rewriter** class is used by the [Lexer](lexer.html), directly against
  // its internal array of tokens.
  exports.Rewriter = Rewriter = (function() {
    function Rewriter() {} /* Rewrite the token stream in multiple passes, one logical filter at */  /* a time. This could certainly be changed into a single pass through the */  /* stream, with a big ol' efficient switch, but it's much nicer to work with */  /* like this. The order of these passes matters -- indentation must be */  /* corrected before implicit parentheses can be wrapped around blocks of code. */ 

    Rewriter.prototype.rewrite = function(tokens1) {
      // Helpful snippet for debugging:
      //     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
      //@rewriteComments()
      this.tokens = tokens1;
      this.removeLeadingNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.normalizeLines();
      this.tagPostfixConditionals();
      this.addImplicitBracesAndParens();
      this.addLocationDataToGeneratedTokens();
      this.fixOutdentLocationData();
      return this.tokens;
    };

    // Rewrite the token stream, looking one token ahead and behind.
    // Allow the return value of the block to tell us how many tokens to move
    // forwards (or backwards) in the stream, to make sure we don't miss anything
    // as tokens are inserted and removed, and the stream changes length under
    // our feet.
    Rewriter.prototype.scanTokens = function(block) {
      var token, tokens;
      tokens = this.tokens;
      let i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var ref, ref1, token, tokens;
      tokens = this.tokens;
      let levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
          levels += 1;
        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    // Leading newlines would introduce an ambiguity in the grammar, so we
    // dispatch them here.
    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, k, len, ref, tag;
      ref = this.tokens;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        tag = ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    // The lexer has tagged the opening parenthesis of a method call. Match it with
    // its paired close. We have the mis-nested outdent case included here for
    // calls that close on the same line, just before their outdent.
    Rewriter.prototype.closeOpenCalls = function() {
      let condition = function(token, i) {
        var ref;
        return ((ref = token[0]) === ')' || ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
      };
      let action = function(token, i) {
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    // The lexer has tagged the opening parenthesis of an indexing operation call.
    // Match it with its paired close.
    Rewriter.prototype.closeOpenIndexes = function() {
      let condition = function(token, i) {
        var ref;
        return (ref = token[0]) === ']' || ref === 'INDEX_END';
      };
      let action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    // Match tags in token stream starting at `i` with `pattern`, skipping 'HERECOMMENT's.
    // `pattern` may consist of strings (equality), an array of strings (one of)
    // or null (wildcard). Returns the index of the match or -1 if no match.
    Rewriter.prototype.indexOfTag = function() {
      var i, j, k, pattern, ref, ref1;
      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      let fuzz = 0;
      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {
          fuzz += 2;
        }
        if (pattern[j] == null) {
          continue;
        }
        if (typeof pattern[j] === 'string') {
          pattern[j] = [pattern[j]];
        }
        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {
          return -1;
        }
      }
      return i + j + fuzz - 1;
    };

    // Returns `yes` if standing in front of something looking like
    // `@<x>:`, `<x>:` or `<EXPRESSION_START><x>...<EXPRESSION_END>:`,
    // skipping over 'HERECOMMENT's.
    Rewriter.prototype.looksObjectish = function(j) {
      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) {
        return true;
      }
      let index = this.indexOfTag(j, EXPRESSION_START);
      if (index > -1) {
        let end = null;
        this.detectEnd(index + 1, (function(token) {
          var ref;
          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;
        }), (function(token, i) {
          return end = i;
        }));
        if (this.tag(end + 1) === ':') {
          return true;
        }
      }
      return false;
    };

    // Returns `yes` if current line of tokens contain an element of tags on same
    // expression level. Stop searching at LINEBREAKS or explicit start of
    // containing balanced expression.
    Rewriter.prototype.findTagsBackwards = function(i, tags) {
      var ref, ref1, ref2, ref3, ref4, ref5;
      let backStack = [];
      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {
        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {
          backStack.push(this.tag(i));
        }
        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {
          backStack.pop();
        }
        i -= 1;
      }
      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;
    };

    // Look for signs of implicit calls and objects in the token stream and
    // add them.
    Rewriter.prototype.addImplicitBracesAndParens = function() {
      // Track current balancing depth (both implicit and explicit) on stack.
      let stack = [];
      let start = null;
      return this.scanTokens(function(token, i, tokens) {
        var k, nextTag, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, sameLine, stackIdx, stackItem, stackTag, startsLine, tag;
        tag = token[0];
        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];
        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];
        let stackTop = function() {
          return stack[stack.length - 1];
        };
        let startIdx = i;
        // Helper function, used for keeping track of the number of tokens consumed
        // and spliced, when returning for getting a new token.
        let forward = function(n) {
          return i - startIdx + n;
        };
        // Helper functions
        let isImplicit = function(stackItem) {
          var ref;
          return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;
        };
        let isImplicitObject = function(stackItem) {
          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';
        };
        let isImplicitCall = function(stackItem) {
          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';
        };
        let inImplicit = function() {
          return isImplicit(stackTop());
        };
        let inImplicitCall = function() {
          return isImplicitCall(stackTop());
        };
        let inImplicitObject = function() {
          return isImplicitObject(stackTop());
        };
        // Unclosed control statement inside implicit parens (like
        // class declaration or if-conditionals)
        let inImplicitControl = function() {
          var ref;
          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';
        };
        let startImplicitCall = function(j) {
          let idx = j != null ? j : i;
          stack.push([
            '(', idx, {
              ours: true
            }
          ]);
          tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]]));
          if (j == null) {
            return i += 1;
          }
        };
        let endImplicitCall = function() {
          stack.pop();
          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));
          return i += 1;
        };
        let startImplicitObject = function(j, startsLine) {
          if (startsLine == null) {
            startsLine = true;
          }
          let idx = j != null ? j : i;
          stack.push([
            '{', idx, {
              sameLine: true,
              startsLine: startsLine,
              ours: true
            }
          ]);
          let val = new String('{');
          val.generated = true;
          tokens.splice(idx, 0, generate('{', val, token));
          if (j == null) {
            return i += 1;
          }
        };
        let endImplicitObject = function(j) {
          j = j != null ? j : i;
          stack.pop();
          tokens.splice(j, 0, generate('}', '}', token));
          return i += 1;
        };
        // Don't end an implicit call on next indent if any of these are in an argument
        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {
          stack.push([
            'CONTROL', i, {
              ours: true
            }
          ]);
          return forward(1);
        }
        if (tag === 'INDENT' && inImplicit()) {
          // An `INDENT` closes an implicit call unless
          //
          //  1. We have seen a `CONTROL` argument on the line.
          //  2. The last token before the indent is part of the list below
          //
          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {
            while (inImplicitCall()) {
              endImplicitCall();
            }
          }
          if (inImplicitControl()) {
            stack.pop();
          }
          stack.push([tag, i]);
          return forward(1);
        }
        // Straightforward start of explicit expression
        if (indexOf.call(EXPRESSION_START, tag) >= 0) {
          stack.push([tag, i]);
          return forward(1);
        }
        // Close all implicit expressions inside of explicitly closed expressions.
        if (indexOf.call(EXPRESSION_END, tag) >= 0) {
          while (inImplicit()) {
            if (inImplicitCall()) {
              endImplicitCall();
            } else if (inImplicitObject()) {
              endImplicitObject();
            } else {
              stack.pop();
            }
          }
          start = stack.pop();
        }
        // Recognize standard implicit calls like
        // f a, f() b, f? c, h[0] d etc.
        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {
          if (tag === '?') {
            tag = token[0] = 'FUNC_EXIST';
          }
          startImplicitCall(i + 1);
          return forward(2);
        }
        // Implicit call taking an implicit indented object as first argument.
        //
        //     f
        //       a: b
        //       c: d
        //
        // and
        //
        //     f
        //       1
        //       a: b
        //       b: c
        //
        // Don't accept implicit calls of this type, when on the same line
        // as the control structures below as that may misinterpret constructs like:
        //
        //     if f
        //        a: 1
        // as
        //
        //     if f(a: 1)
        //
        // which is probably always unintended.
        // Furthermore don't allow this in literal arrays, as
        // that creates grammatical ambiguities.
        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {
          startImplicitCall(i + 1);
          stack.push(['INDENT', i + 2]);
          return forward(3);
        }
        // Implicit objects start here
        if (tag === ':') {
          // Go back to the (implicit) start of the object
          let s = (function() {
            var ref2;
            switch (false) {
              case ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0:
                return start[1];
              case this.tag(i - 2) !== '@':
                return i - 2;
              default:
                return i - 1;
            }
          }).call(this);
          while (this.tag(s - 2) === 'HERECOMMENT') {
            s -= 2;
          }
          // Mark if the value is a for loop
          this.insideForDeclaration = nextTag === 'FOR';
          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;
          // Are we just continuing an already declared object?
          if (stackTop()) {
            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];
            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {
              return forward(1);
            }
          }
          startImplicitObject(s, !!startsLine);
          return forward(2);
        }
        // End implicit calls when chaining method calls
        // like e.g.:
        //
        //     f ->
        //       a
        //     .g b, ->
        //       c
        //     .h a
        //
        // and also
        //
        //     f a
        //     .g b
        //     .h a
        // Mark all enclosing objects as not sameLine
        if (indexOf.call(LINEBREAKS, tag) >= 0) {
          for (k = stack.length - 1; k >= 0; k += -1) {
            stackItem = stack[k];
            if (!isImplicit(stackItem)) {
              break;
            }
            if (isImplicitObject(stackItem)) {
              stackItem[2].sameLine = false;
            }
          }
        }
        let newLine = prevTag === 'OUTDENT' || prevToken.newLine;
        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {
          while (inImplicit()) {
            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);
            // Close implicit calls when reached end of argument list
            if (inImplicitCall() && prevTag !== ',') {
              endImplicitCall();
            } else  /* Close implicit objects such as: */  /* return a: 1, b: 2 unless true */ if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') {
              endImplicitObject();
            } else  /* Close implicit objects when at end of line, line didn't end with a comma */  /* and the implicit object didn't start the line or the next line doesn't look like */  /* the continuation of an object. */ if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {
              if (nextTag === 'HERECOMMENT') {
                return forward(1);
              }
              endImplicitObject();
            } else {
              break;
            }
          }
        }
        // Close implicit object if comma is the last character
        // and what comes after doesn't look like it belongs.
        // This is used for trailing commas and calls, like:
        //
        //     x =
        //         a: b,
        //         c: d,
        //     e = 2
        //
        // and
        //
        //     f a, b: c, d: e, f, g: h: i, j
        //
        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {
          // When nextTag is OUTDENT the comma is insignificant and
          // should just be ignored so embed it in the implicit object.
          //
          // When it isn't the comma go on to play a role in a call or
          // array further up the stack, so give it a chance.
          let offset = nextTag === 'OUTDENT' ? 1 : 0;
          while (inImplicitObject()) {
            endImplicitObject(i + offset);
          }
        }
        return forward(1);
      });
    };

    // Add location data to all tokens generated by the rewriter.
    Rewriter.prototype.addLocationDataToGeneratedTokens = function() {
      return this.scanTokens(function(token, i, tokens) {
        var column, line, nextLocation, prevLocation, ref, ref1;
        if (token[2]) {
          return 1;
        }
        if (!(token.generated || token.explicit)) {
          return 1;
        }
        if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {
          line = nextLocation.first_line, column = nextLocation.first_column;
        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {
          line = prevLocation.last_line, column = prevLocation.last_column;
        } else {
          line = column = 0;
        }
        token[2] = {
          first_line: line,
          first_column: column,
          last_line: line,
          last_column: column
        };
        return 1;
      });
    };

    // OUTDENT tokens should always be positioned at the last character of the
    // previous token, so that AST nodes ending in an OUTDENT token end up with a
    // location corresponding to the last "real" token under the node.
    Rewriter.prototype.fixOutdentLocationData = function() {
      return this.scanTokens(function(token, i, tokens) {
        if (!(token[0] === 'OUTDENT' || (token.generated && token[0] === 'CALL_END') || (token.generated && token[0] === '}'))) {
          return 1;
        }
        let prevLocationData = tokens[i - 1][2];
        token[2] = {
          first_line: prevLocationData.last_line,
          first_column: prevLocationData.last_column,
          last_line: prevLocationData.last_line,
          last_column: prevLocationData.last_column
        };
        return 1;
      });
    };

    // Because our grammar is LALR(1), it can't handle some single-line
    // expressions that lack ending delimiters. The **Rewriter** adds the implicit
    // blocks, so it doesn't need to. To keep the grammar clean and tidy, trailing
    // newlines within expressions are removed and the indentation tokens of empty
    // blocks are added.
    Rewriter.prototype.normalizeLines = function() {
      var indent, outdent;
      let starter = indent = outdent = null;
      let condition = function(token, i) {
        var ref, ref1, ref2, ref3;
        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');
      };
      let action = function(token, i) {
        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
      };
      return this.scanTokens(function(token, i, tokens) {
        var j, k, ref, ref1, ref2, tag;
        tag = token[0];
        if (tag === 'TERMINATOR') {
          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));
            return 1;
          }
          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {
            tokens.splice(i, 1);
            return 0;
          }
        }
        if (tag === 'CATCH') {
          for (j = k = 1; k <= 2; j = ++k) {
            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {
              continue;
            }
            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));
            return 2 + j;
          }
        }
        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {
          starter = tag;
          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];
          if (starter === 'THEN') {
            indent.fromThen = true;
          }
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.rewriteComments = function() {
      let savedComments = [];
      this.scanTokens(function(token, i, tokens) {
        var locationData, ref, ref1, ref2, tag, text;
        tag = token[0], text = token[1], locationData = token[2];
        if (tag === 'HERECOMMENT') {
          let prev = (ref = tokens[i - 1]) != null ? ref[0] : void 0;
          let next = (ref1 = tokens[i + 1]) != null ? ref1[0] : void 0;
          let fullLine = false;
          let endOfLine = false;
          if ((!prev || prev === 'TERMINATOR') && (!next || next === 'TERMINATOR')) {
            fullLine = true;
          } else if (!next || next === 'TERMINATOR') {
            endOfLine = true;
          }
          let jsdoc = (ref2 = text.match(/^@(type|param)/)) != null ? ref2[1] : void 0;
          savedComments.push({
            tag: tag,
            text: text,
            locationData: locationData,
            fullLine: fullLine,
            endOfLine: endOfLine,
            jsdoc: jsdoc
          });
          // Remove comment token.
          tokens.splice(i, 1);
          if (fullLine) {
            // Remove the TERMINATOR as well so we don't end up with a newline
            // after a newline - grammar does not expect that.
            tokens.splice(i, 1);
          }
          return 0;
        } else {
          // Not a comment.
          return 1;
        }
      });
      return this.comments = savedComments;
    };

    // Tag postfix conditionals as such, so that we can parse them with a
    // different precedence.
    Rewriter.prototype.tagPostfixConditionals = function() {
      let original = null;
      let condition = function(token, i) {
        var prevTag, tag;
        tag = token[0];
        prevTag = this.tokens[i - 1][0];
        return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);
      };
      let action = function(token, i) {
        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {
          return original[0] = 'POST_' + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    // Generate the indentation tokens, based on another token on the same line.
    Rewriter.prototype.indentation = function(origin) {
      let indent = ['INDENT', 2];
      let outdent = ['OUTDENT', 2];
      if (origin) {
        indent.generated = outdent.generated = true;
        indent.origin = outdent.origin = origin;
      } else {
        indent.explicit = outdent.explicit = true;
      }
      return [indent, outdent];
    };

    Rewriter.prototype.generate = generate;

    // Look up a tag by token index.
    Rewriter.prototype.tag = function(i) {
      var ref;
      return (ref = this.tokens[i]) != null ? ref[0] : void 0;
    };

    return Rewriter;

  })();

  // Constants
  // ---------
  // List of the token pairs that must be balanced.
  let BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];

  // The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
  // look things up from either end.
  exports.INVERSES = INVERSES = {};

  // The tokens that signal the start/end of a balanced pair.
  let EXPRESSION_START = [];

  let EXPRESSION_END = [];

  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {
    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  // Tokens that indicate the close of a clause of an expression.
  let EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  // Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
  let IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  // If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
  let IMPLICIT_CALL = ['IDENTIFIER', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];

  let IMPLICIT_UNSPACED_CALL = ['+', '-'];

  // Tokens that always mark the end of an implicit call for single-liners.
  let IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  // Single-line flavors of block expressions that have unclosed endings.
  // The grammar can't disambiguate them, so we insert the implicit indentation.
  let SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  let SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  // Tokens that end a line.
  let LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  // Tokens that close open calls when they follow a newline.
  let CALL_CLOSERS = ['.', '?.', '::', '?::'];

  // IcedCoffeeScript additions
  IMPLICIT_FUNC.push('DEFER');

  IMPLICIT_CALL.push('DEFER');

  IMPLICIT_END.push('AWAIT');

}).call(this);
