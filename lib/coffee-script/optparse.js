// Generated by IcedCoffeeScript 112.8.0
(function() {
  var OptionParser, repeat;

  repeat = require('./helpers').repeat;

  // A simple **OptionParser** class to parse option flags from the command-line.
  // Use it like so:
  //
  //     parser  = new OptionParser switches, helpBanner
  //     options = parser.parse process.argv
  //
  // The first non-option is considered to be the start of the file (and file
  // option) list, and all subsequent arguments are left unparsed.
  exports.OptionParser = OptionParser = (function() {
    // Initialize with a list of valid options, in the form:
    //
    //     [short-flag, long-flag, description]
    //
    // Along with an optional banner for the usage help.
    function OptionParser(rules, banner) {
      this.banner = banner;
      this.rules = buildRules(rules);
    }

    // Parse the list of arguments, populating an `options` object with all of the
    // specified options, and return it. Options after the first non-option
    // argument are treated as arguments. `options.arguments` will be an array
    // containing the remaining arguments. This is a simpler API than many option
    // parsers that allow you to attach callback actions for every flag. Instead,
    // you're responsible for interpreting the options object.
    OptionParser.prototype.parse = function(args) {
      var arg, i, j, k, len, len1, ref, rule;
      let options = {
        "arguments": []
      };
      let skippingArgument = false;
      let originalArgs = args;
      args = normalizeArguments(args);
      for (i = j = 0, len = args.length; j < len; i = ++j) {
        arg = args[i];
        if (skippingArgument) {
          skippingArgument = false;
          continue;
        }
        if (arg === '--') {
          let pos = originalArgs.indexOf('--');
          options["arguments"] = options["arguments"].concat(originalArgs.slice(pos + 1));
          break;
        }
        let isOption = !!(arg.match(LONG_FLAG) || arg.match(SHORT_FLAG));
        // the CS option parser is a little odd; options after the first
        // non-option argument are treated as non-option arguments themselves
        let seenNonOptionArg = options["arguments"].length > 0;
        if (!seenNonOptionArg) {
          let matchedRule = false;
          ref = this.rules;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            rule = ref[k];
            if (rule.shortFlag === arg || rule.longFlag === arg) {
              let value = true;
              if (rule.hasArgument) {
                skippingArgument = true;
                value = args[i + 1];
              }
              options[rule.name] = rule.isList ? (options[rule.name] || []).concat(value) : value;
              matchedRule = true;
              break;
            }
          }
          if (isOption && !matchedRule) {
            throw new Error("unrecognized option: " + arg);
          }
        }
        if (seenNonOptionArg || !isOption) {
          options["arguments"].push(arg);
        }
      }
      return options;
    };

    // Return the help text for this **OptionParser**, listing and describing all
    // of the valid options, for `--help` and such.
    OptionParser.prototype.help = function() {
      var j, len, ref, rule;
      let lines = [];
      if (this.banner) {
        lines.unshift(this.banner + "\n");
      }
      ref = this.rules;
      for (j = 0, len = ref.length; j < len; j++) {
        rule = ref[j];
        let spaces = 15 - rule.longFlag.length;
        spaces = spaces > 0 ? repeat(' ', spaces) : '';
        let letPart = rule.shortFlag ? rule.shortFlag + ', ' : '    ';
        lines.push('  ' + letPart + rule.longFlag + spaces + rule.description);
      }
      return "\n" + (lines.join('\n')) + "\n";
    };

    return OptionParser;

  })();

  // Helpers
  // -------
  // Regex matchers for option flags.
  let LONG_FLAG = /^(--\w[\w\-]*)/;

  let SHORT_FLAG = /^(-\w)$/;

  let MULTI_FLAG = /^-(\w{2,})/;

  let OPTIONAL = /\[(\w+(\*?))\]/;

  // Build and return the list of option rules. If the optional *short-flag* is
  // unspecified, leave it out by padding with `null`.
  let buildRules = function(rules) {
    var j, len, results, tuple;
    results = [];
    for (j = 0, len = rules.length; j < len; j++) {
      tuple = rules[j];
      if (tuple.length < 3) {
        tuple.unshift(null);
      }
      results.push(buildRule.apply(null, tuple));
    }
    return results;
  };

  // Build a rule from a `-o` short flag, a `--output [DIR]` long flag, and the
  // description of what the option does.
  let buildRule = function(shortFlag, longFlag, description, options) {
    if (options == null) {
      options = {};
    }
    let match = longFlag.match(OPTIONAL);
    longFlag = longFlag.match(LONG_FLAG)[1];
    return {
      name: longFlag.substr(2),
      shortFlag: shortFlag,
      longFlag: longFlag,
      description: description,
      hasArgument: !!(match && match[1]),
      isList: !!(match && match[2])
    };
  };

  // Normalize arguments by expanding merged flags into multiple flags. This allows
  // you to have `-wl` be the same as `--watch --lint`.
  let normalizeArguments = function(args) {
    var arg, j, k, l, len, len1, match, ref;
    args = args.slice(0);
    let result = [];
    for (j = 0, len = args.length; j < len; j++) {
      arg = args[j];
      if (match = arg.match(MULTI_FLAG)) {
        ref = match[1].split('');
        for (k = 0, len1 = ref.length; k < len1; k++) {
          l = ref[k];
          result.push('-' + l);
        }
      } else {
        result.push(arg);
      }
    }
    return result;
  };

}).call(this);
