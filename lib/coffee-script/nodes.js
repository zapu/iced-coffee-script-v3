// Generated by IcedCoffeeScript 112.8.0
// `nodes.coffee` contains all of the node classes for the syntax tree. Most
// nodes are created as the result of actions in the [grammar](grammar.html),
// but some are created by other nodes as a method of code generation. To convert
// the syntax tree into a string of JavaScript code, call `compile()` on the root.
(function() {
  var Access, Arr, Assign, Await, BUILTIN_ICED_VER_LITERAL, Base, Block, BooleanLiteral, Call, Class, Code, CodeFragment, Comment, Defer, Existence, Expansion, ExportAllDeclaration, ExportDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, ExportSpecifierList, Extends, For, IcedRuntime, IdentifierLiteral, If, ImportClause, ImportDeclaration, ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier, ImportSpecifierList, In, Index, InfinityLiteral, JS_FORBIDDEN, Literal, ModuleDeclaration, ModuleSpecifier, ModuleSpecifierList, NaNLiteral, NullLiteral, NumberLiteral, Obj, Op, Param, Parens, PassthroughLiteral, PropertyName, Range, RegexLiteral, RegexWithInterpolations, Return, Scope, Slice, Slot, Splat, StatementLiteral, StringLiteral, StringWithInterpolations, SuperCall, Switch, TaggedTemplateCall, ThisLiteral, Throw, Try, UndefinedLiteral, Value, While, YieldReturn, addLocationDataFn, compact, del, ends, extend, flatten, isUnassignable, locationDataToString, merge, ref1, ref2, some, starts, strToJavascript, throwSyntaxError,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  Error.stackTraceLimit = 2e308;

  Scope = require('./scope').Scope;

  ref1 = require('./lexer'), isUnassignable = ref1.isUnassignable, JS_FORBIDDEN = ref1.JS_FORBIDDEN, BUILTIN_ICED_VER_LITERAL = ref1.BUILTIN_ICED_VER_LITERAL;

  let iced = require('iced-runtime-3');

  // Import the helpers we plan to use.
  ref2 = require('./helpers'), compact = ref2.compact, flatten = ref2.flatten, extend = ref2.extend, merge = ref2.merge, del = ref2.del, starts = ref2.starts, ends = ref2.ends, some = ref2.some, addLocationDataFn = ref2.addLocationDataFn, locationDataToString = ref2.locationDataToString, throwSyntaxError = ref2.throwSyntaxError, strToJavascript = ref2.strToJavascript;

  // Functions required by parser
  exports.extend = extend;

  exports.addLocationDataFn = addLocationDataFn;

  // Constant functions for nodes that don't need customization.
  let YES = function() {
    return true;
  };

  let NO = function() {
    return false;
  };

  let THIS = function() {
    return this;
  };

  let NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };

  //### CodeFragment
  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = (function() {
    function CodeFragment(parent, code) {
      var ref3;
      this.code = "" + code;
      this.locationData = parent != null ? parent.locationData : void 0;
      this.type = (parent != null ? (ref3 = parent.constructor) != null ? ref3.name : void 0 : void 0) || 'unknown';
    }

    CodeFragment.prototype.toString = function() {
      return "" + this.code + (this.locationData ? ": " + locationDataToString(this.locationData) : '');
    };

    return CodeFragment;

  })();

  // Convert an array of CodeFragments into a string.
  let fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = fragments.length; j < len1; j++) {
        fragment = fragments[j];
        results.push(fragment.code);
      }
      return results;
    })()).join('');
  };

  //### Base
  // The **Base** is the abstract base class for all nodes in the syntax tree.
  // Each subclass implements the `compileNode` method, which performs the
  // code generation for that node. To compile a node to JavaScript,
  // call `compile` on it, which wraps `compileNode` in some generic extra smarts,
  // to know when the generated code needs to be wrapped up in a closure.
  // An options hash is passed and cloned throughout, containing information about
  // the environment from higher in the tree (such as if a returned value is
  // being requested by the surrounding function), information about the current
  // scope, and indentation level.
  exports.Base = Base = (function() {
    function Base() {}

    Base.prototype.compile = function(o, lvl) {
      return fragmentsToText(this.compileToFragments(o, lvl));
    };

    // Common logic for determining whether to wrap this node in a closure before
    // compiling it, or to compile directly. We need to wrap if this node is a
    // *statement*, and it's not a *pureStatement*, and we're not at
    // the top level of a block (which would be unnecessary), and we haven't
    // already been asked to return the result (because statements know how to
    // return results).
    Base.prototype.compileToFragments = function(o, lvl) {
      o = extend({}, o);
      if (lvl) {
        o.level = lvl;
      }
      let node = this.unfoldSoak(o) || this;
      node.tab = o.indent;
      if (o.level === LEVEL_TOP || !node.isStatement(o)) {
        return node.compileNode(o);
      } else {
        return node.compileClosure(o);
      }
    };

    // Statements converted into expressions via closure-wrapping share a scope
    // object with their parent closure, to preserve the expected lexical scope.
    Base.prototype.compileClosure = function(o) {
      var argumentsNode, jumpNode, meth, ref3;
      if (jumpNode = this.jumps()) {
        jumpNode.error('cannot use a pure statement in an expression');
      }
      o.sharedScope = true;
      let func = new Code([], Block.wrap([this]));
      let args = [];
      if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
        args = [new ThisLiteral];
        if (argumentsNode) {
          meth = 'apply';
          args.push(new IdentifierLiteral('arguments'));
        } else {
          meth = 'call';
        }
        func = new Value(func, [new Access(new PropertyName(meth))]);
      }
      let parts = (new Call(func, args)).compileNode(o);
      if (func.isGenerator || ((ref3 = func.base) != null ? ref3.isGenerator : void 0)) {
        parts.unshift(this.makeCode("(yield* "));
        parts.push(this.makeCode(")"));
      }
      return parts;
    };

    // If the code generation wishes to use the result of a complex expression
    // in multiple places, ensure that the expression is only ever evaluated once,
    // by assigning it to a temporary variable. Pass a level to precompile.
    //
    // If `level` is passed, then returns `[val, ref]`, where `val` is the compiled value, and `ref`
    // is the compiled reference. If `level` is not passed, this returns `[val, ref]` where
    // the two values are raw nodes which have not been compiled.
    Base.prototype.cache = function(o, level, isComplex) {
      var ref;
      let complex = isComplex != null ? isComplex(this) : this.isComplex();
      if (complex) {
        ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
        let sub = new Assign(ref, this);
        if (level) {
          return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
        } else {
          return [sub, ref];
        }
      } else {
        ref = level ? this.compileToFragments(o, level) : this;
        return [ref, ref];
      }
    };

    Base.prototype.cacheToCodeFragments = function(cacheValues) {
      return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
    };

    // Construct a node that returns the current node's result.
    // Note that this is overridden for smarter behavior for
    // many statement nodes (e.g. If, For)...
    Base.prototype.makeReturn = function(res) {
      let me = this.unwrapAll();
      if (res) {
        return new Call(new Literal(res + ".push"), [me]);
      } else {
        return new Return(me);
      }
    };

    // Does this node, or any of its children, contain a node of a certain kind?
    // Recursively traverses down the *children* nodes and returns the first one
    // that verifies `pred`. Otherwise return undefined. `contains` does not cross
    // scope boundaries.
    Base.prototype.contains = function(pred) {
      let node = void 0;
      this.traverseChildren(false, function(n) {
        if (pred(n)) {
          node = n;
          return false;
        }
      });
      return node;
    };

    // Pull out the last non-comment node of a node list.
    Base.prototype.lastNonComment = function(list) {
      let i = list.length;
      while (i--) {
        if (!(list[i] instanceof Comment)) {
          return list[i];
        }
      }
      return null;
    };

    // `toString` representation of the node, for inspecting the parse tree.
    // This is what `coffee --nodes` prints out.
    Base.prototype.toString = function(idt, name) {
      if (idt == null) {
        idt = '';
      }
      if (name == null) {
        name = this.constructor.name;
      }
      let tree = '\n' + idt + name;
      if (this.soak) {
        tree += '?';
      }
      tree = this.icedToString(tree);
      this.eachChild(function(node) {
        return tree += node.toString(idt + TAB);
      });
      return tree;
    };

    Base.prototype.toStringCompact = function() {
      return this.toString().replace(/\s(\S)/g, ' >$1').replace(/[ ]{2}/g, '-').replace(/\n/g, '');
    };

    // Passes each child to a function, breaking when the function returns `false`.
    Base.prototype.eachChild = function(func) {
      var attr, child, j, k, len1, len2, ref3, ref4;
      if (!this.children) {
        return this;
      }
      ref3 = this.children;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        attr = ref3[j];
        if (this[attr]) {
          ref4 = flatten([this[attr]]);
          for (k = 0, len2 = ref4.length; k < len2; k++) {
            child = ref4[k];
            if (func(child) === false) {
              return this;
            }
          }
        }
      }
      return this;
    };

    Base.prototype.traverseChildren = function(crossScope, func) {
      return this.eachChild(function(child) {
        let recur = func(child);
        if (recur !== false) {
          return child.traverseChildren(crossScope, func);
        }
      });
    };

    Base.prototype.invert = function() {
      return new Op('!', this);
    };

    Base.prototype.unwrapAll = function() {
      let node = this;
      while (node !== (node = node.unwrap())) {
        continue;
      }
      return node;
    };

    // Default implementations of the common node properties and methods. Nodes
    // will override these with custom logic, if needed.
    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.isNumber = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    // Is this node used to assign a certain variable?
    Base.prototype.assigns = NO;

    // Should not be spaced when compiling root level Block
    Base.prototype.sticky = NO;

    // For this node and all descendents, set the location data to `locationData`
    // if the location data is not already set.
    Base.prototype.updateLocationDataIfMissing = function(locationData) {
      if (this.locationData) {
        return this;
      }
      this.locationData = locationData;
      return this.eachChild(function(child) {
        return child.updateLocationDataIfMissing(locationData);
      });
    };

    // Throw a SyntaxError associated with this node's location.
    Base.prototype.error = function(message) {
      return throwSyntaxError(message, this.locationData);
    };

    Base.prototype.makeCode = function(code) {
      return new CodeFragment(this, code);
    };

    Base.prototype.wrapInBraces = function(fragments) {
      return [].concat(this.makeCode('('), fragments, this.makeCode(')'));
    };

    // `fragmentsList` is an array of arrays of fragments. Each array in fragmentsList will be
    // concatonated together, with `joinStr` added in between each, to produce a final flat array
    // of fragments.
    Base.prototype.joinFragmentArrays = function(fragmentsList, joinStr) {
      var fragments, i, j, len1;
      let answer = [];
      for (i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j) {
        fragments = fragmentsList[i];
        if (i) {
          answer.push(this.makeCode(joinStr));
        }
        answer = answer.concat(fragments);
      }
      return answer;
    };

    //------
    // Begin Iced Additions...
    Base.prototype.icedToString = function(tree) {
      let extras = [];
      if (this.icedFlag) {
        extras.push("I");
      }
      extras = extras.length ? " (" + extras.join('') + ")" : "";
      return tree + extras;
    };

    // Don't try this at home with actual human kids. Added for iced
    // for slightly different tree traversal mechanics.
    Base.prototype.icedFlattenChildren = function() {
      var attr, child, j, k, len1, len2, ref3, ref4;
      let out = [];
      ref3 = this.children;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        attr = ref3[j];
        if (this[attr]) {
          ref4 = flatten([this[attr]]);
          for (k = 0, len2 = ref4.length; k < len2; k++) {
            child = ref4[k];
            out.push(child);
          }
        }
      }
      return out;
    };

    // Walk the AST marking functions as being "iced" if they contain at least
    // one await in the current function. Keep state for this walk in the 'o'
    // object being passed.
    //
    // Relevant fields:
    //   - members of the various AST nodes:
    //       - icedFlag -- true if this node is an await or one of the await's
    //          ancestors in the AST.
    //       - icedParentAwait -- for defer()'s, the parent Await block
    //       - icedParentFunc -- for await's, the parent function
    //   - members of the `o` traversal object:
    //       - await -- the await block we descend from (or null)
    //       - func -- the function we descend from (or null)
    //       - awaitInFunc -- whether we've found an await block in this function
    //       - awaitInFile -- whether we've found an await block in this file
    //       - deferInFile -- on if a defer was found anywhere in the file
    //
    Base.prototype.icedWalkAst = function(o) {
      var child, j, len1, ref3, results;
      ref3 = this.icedFlattenChildren();
      results = [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        child = ref3[j];
        results.push(child.icedWalkAst(o));
      }
      return results;
    };

    Base.prototype.containsAwait = function() {
      return this.contains(function(node) {
        return node instanceof Await;
      });
    };

    // Traverse children and check if there is any await statement. This
    // is used to generate an error when user tries to use an expression
    // with Await in illegal places, like If's condition, Call arguments,
    // right side of Assign, etc.
    Base.prototype.icedStatementAssertion = function() {
      // TODO: Ideally this would be detected and saved in one of the
      // tree-walking routines, so we don't walk the tree (potentially
      // visiting same nodes over and over) every time someone calls this
      // method.
      if (this.containsAwait()) {
        return this.error("await'ed statements can't act as expressions");
      }
    };

    Base.prototype.variableDeclarationWalk = function(opts) {
      var child, j, len1, ref3, results;
      ref3 = this.icedFlattenChildren();
      results = [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        child = ref3[j];
        results.push(child.variableDeclarationWalk(opts));
      }
      return results;
    };

    return Base;

  })();

  // End Iced Additions...
  //------
  //### Block
  // The block is the list of expressions that forms the body of an
  // indented block of code -- the implementation of a function, a clause in an
  // `if`, `switch`, or `try`, and so on...
  exports.Block = Block = (function(superClass1) {
    extend1(Block, superClass1);

    function Block(nodes) {
      this.expressions = compact(flatten(nodes || []));
    }

    Block.prototype.children = ['expressions'];

    // Tack an expression on to the end of this expression list.
    Block.prototype.push = function(node) {
      this.expressions.push(node);
      return this;
    };

    // Remove and return the last expression of this expression list.
    Block.prototype.pop = function() {
      return this.expressions.pop();
    };

    // Add an expression at the beginning of this expression list.
    Block.prototype.unshift = function(node) {
      this.expressions.unshift(node);
      return this;
    };

    // If this Block consists of just a single node, unwrap it by pulling
    // it back out.
    Block.prototype.unwrap = function() {
      if (this.expressions.length === 1) {
        return this.expressions[0];
      } else {
        return this;
      }
    };

    // Is this an empty block of code?
    Block.prototype.isEmpty = function() {
      return !this.expressions.length;
    };

    Block.prototype.isStatement = function(o) {
      var exp, j, len1, ref3;
      ref3 = this.expressions;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        exp = ref3[j];
        if (exp.isStatement(o)) {
          return true;
        }
      }
      return false;
    };

    Block.prototype.jumps = function(o) {
      var exp, j, jumpNode, len1, ref3;
      ref3 = this.expressions;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        exp = ref3[j];
        if (jumpNode = exp.jumps(o)) {
          return jumpNode;
        }
      }
    };

    // A Block node does not return its entire body, rather it
    // ensures that the final expression is returned.
    Block.prototype.makeReturn = function(res) {
      let len = this.expressions.length;
      while (len--) {
        let expr = this.expressions[len];
        if (!(expr instanceof Comment)) {
          this.expressions[len] = expr.makeReturn(res);
          this.expressions[len].updateLocationDataIfMissing(expr.locationData);
          if (expr instanceof Return && !expr.expression) {
            this.expressions.splice(len, 1);
          }
          break;
        }
      }
      return this;
    };

    // A **Block** is the only node that can serve as the root.
    Block.prototype.compileToFragments = function(o, level) {
      if (o == null) {
        o = {};
      }
      if (o.scope) {
        return Block.__super__.compileToFragments.call(this, o, level);
      } else {
        return this.compileRoot(o);
      }
    };

    // Compile all expressions within the **Block** body. If we need to
    // return the result, and it's an expression, simply return it. If it's a
    // statement, ask the statement to do so.
    Block.prototype.compileNode = function(o) {
      var answer, index, j, len1, node, ref3;
      this.tab = o.indent;
      let top = o.level === LEVEL_TOP;
      let compiledNodes = [];
      ref3 = this.expressions;
      for (index = j = 0, len1 = ref3.length; j < len1; index = ++j) {
        node = ref3[index];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        if (node instanceof Block) {
          // This is a nested block. We don't do anything special here like enclose
          // it in a new scope; we just compile the statements in this block along with
          // our own
          compiledNodes.push(node.compileNode(o));
        } else if (top) {
          node.front = true;
          let fragments = node.compileToFragments(o);
          if (!node.isStatement(o)) {
            fragments.unshift(this.makeCode("" + this.tab));
            fragments.push(this.makeCode(";"));
          }
          compiledNodes.push(fragments);
          if (this.spaced && !node.sticky()) {
            // Add empty code here, which will cause us to add additional
            // newline when joining codes with `joinFragmentArrays`.
            compiledNodes.push(this.makeCode(""));
          }
        } else {
          compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
        }
      }
      if (top) {
        return this.joinFragmentArrays(compiledNodes, '\n');
      }
      if (compiledNodes.length) {
        answer = this.joinFragmentArrays(compiledNodes, ', ');
      } else {
        answer = [this.makeCode("void 0")];
      }
      if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    // If we happen to be the top-level **Block**, wrap everything in
    // a safety closure, unless requested not to.
    // It would be better not to generate them in the first place, but for now,
    // clean up obvious double-parentheses.
    Block.prototype.compileRoot = function(o) {
      var exp, i, j, len1, name, ref3, ref4;
      o.indent = o.bare ? '' : TAB;
      o.level = LEVEL_TOP;
      this.spaced = true;
      o.scope = new Scope(null, this, null, (ref3 = o.referencedVars) != null ? ref3 : []);
      // Mark given local variables in the root scope as parameters so they don't
      // end up being declared on this block.
      ref4 = o.locals || [];
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        name = ref4[j];
        o.scope.parameter(name);
      }
      this.doVariableDeclarationWalk(o.scope);
      let prelude = [];
      if (!o.bare) {
        let preludeExps = (function() {
          var k, len2, ref5, results;
          ref5 = this.expressions;
          results = [];
          for (i = k = 0, len2 = ref5.length; k < len2; i = ++k) {
            exp = ref5[i];
            //break unless exp.unwrap() instanceof Comment
            // TODO: Figure out if we want some prelude expressions here at all.
            // This would push all the comments out of the closure, but users usually
            // wants comments preceeding functions and similar to stay there, to serve
            // as documentation etc. As well as we want the @type comments to stick to
            // the assignments (this we can detect though).
            // NOTE: @ts-ignore and similar have to be handled differently, push even
            // before "Generated by ..." comment.
            // TODO: Handle @ts-ignore and similar.
            break;
            results.push(exp);
          }
          return results;
        }).call(this);
        let rest = this.expressions.slice(preludeExps.length);
        this.expressions = preludeExps;
        if (preludeExps.length) {
          prelude = this.compileNode(merge(o, {
            indent: ''
          }));
          prelude.push(this.makeCode("\n"));
        }
        this.expressions = rest;
      }
      let fragments = this.compileWithDeclarations(o);
      if (o.bare) {
        return fragments;
      }
      return [].concat(prelude, this.makeCode("(function() {\n"), fragments, this.makeCode("\n}).call(this);\n"));
    };

    // Compile the expressions body for the contents of a function, with
    // declarations of all inner variables pushed up to the top.
    Block.prototype.compileWithDeclarations = function(o) {
      var exp, i, j, len1, ref3, ref4, ref5, scope, spaced;
      let fragments = [];
      let post = [];
      ref3 = this.expressions;
      for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) {
        exp = ref3[i];
        exp = exp.unwrap();
        if (!(exp instanceof Literal)) {
          break;
        }
      }
      o = merge(o, {
        level: LEVEL_TOP
      });
      if (i) {
        let rest = this.expressions.splice(i, 9e9);
        ref4 = [this.spaced, false], spaced = ref4[0], this.spaced = ref4[1];
        ref5 = [this.compileNode(o), spaced], fragments = ref5[0], this.spaced = ref5[1];
        this.expressions = rest;
      }
      post = this.compileNode(o);
      scope = o.scope;
      if (scope.expressions === this) {
        let declars = o.scope.hasDeclarations();
        let assigns = scope.hasAssignments;
        if (declars || assigns) {
          if (i) {
            fragments.push(this.makeCode('\n'));
          }
          fragments.push(this.makeCode(this.tab + "var "));
          if (declars) {
            fragments.push(this.makeCode(scope.declaredVariables().join(', ')));
          }
          if (assigns) {
            if (declars) {
              fragments.push(this.makeCode(",\n" + (this.tab + TAB)));
            }
            fragments.push(this.makeCode(scope.assignedVariables().join(",\n" + (this.tab + TAB))));
          }
          fragments.push(this.makeCode(";\n" + (this.spaced ? '\n' : '')));
        } else if (fragments.length && post.length) {
          fragments.push(this.makeCode("\n"));
        }
      }
      return fragments.concat(post);
    };

    // Wrap up the given nodes as a **Block**, unless it already happens
    // to be one.
    Block.wrap = function(nodes) {
      if (nodes.length === 1 && nodes[0] instanceof Block) {
        return nodes[0];
      }
      return new Block(nodes);
    };

    //--------------------
    // begin Iced Additions
    // Paste in a require or inline code, depending on the strategy requested
    Block.prototype.icedAddRuntime = function(deferInFile, awaitInFile) {
      var node;
      let index = 0;
      while ((node = this.expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()) {
        index++;
      }
      return this.expressions.splice(index, 0, new IcedRuntime(deferInFile, awaitInFile));
    };

    Block.prototype.icedTransform = function(opts) {
      let obj = {};
      // If we have a top-level await, wrap everything in a function.
      if (this.containsAwait()) {
        let wrapper = new Code([], new Block([this.expressions]));
        let boundfunc = new Call(new Value(wrapper, [new Access(new PropertyName('call'))]), [new Literal('this')]);
        this.expressions = [boundfunc];
      }
      this.icedWalkAst(obj);
      // Add a runtime if necessary, but don't add a runtime for the REPL.
      // For some reason, even outputting an empty runtime doesn't work as far as the
      // REPL is concerned.
      if (!(opts != null ? opts.repl : void 0) && (obj.deferInFile || obj.awaitInFile || opts.runforce)) {
        this.icedAddRuntime(obj.deferInFile, obj.awaitInFile);
      }
      // return this for chaining
      return this;
    };

    // Do an AST walk to figure out where variables are declared. If there are clear
    // assignment+declaration point, mark them to emit `var`. Otherwise, variable
    // declarations are emitted as usual, at the top of the scope, by
    // `compileWithDeclarations`.
    Block.prototype.doVariableDeclarationWalk = function(scope) {
      let vmap = new Map();
      let isKill = function(assignList, useList) {
        // If useList does not share a path with assignList, it means
        // that the assignment will not share block scope with use.
        // Example:
        // Block 1 "() ->"
        //   "bar = 5" (bar assignList=[1])
        //   Block 2
        //     "foo = 10" (foo assignList=[1,2])
        //   Block 3
        //     "print foo" (foo useList=[1,3] - kills assignment)
        //     "bar.x()"   (bar useList[1,3] - shares path with [1], same block scope)
        var assignBlk, i, j, len1;
        for (i = j = 0, len1 = assignList.length; j < len1; i = ++j) {
          assignBlk = assignList[i];
          if (!useList[i] || useList[i] !== assignBlk) {
            return true;
          }
        }
        return false;
      };
      let checkVar = function(name, arg1, arg2) {
        var assign, block, blockList, crossedScope, cur, read;
        block = arg1.block, blockList = arg1.blockList, crossedScope = arg1.crossedScope;
        assign = arg2.assign, read = arg2.read;
        let level = blockList.length;
        let blockId = blockList[level - 1];
        if (cur = vmap.get(name)) {
          if (cur.killedBy) {
            // Already dead, do not spend time in isKill
            return;
          }
          //console.log 'is kill?', name, cur.assignList, blockList
          if (isKill(cur.assignList, blockList)) {
            return cur.killedBy = assign != null ? assign : read;
          }
        } else if (!crossedScope) {
          if (assign) {
            // First time we are seeing this variable being assigned to.
            // Candidate for a let-declaration, if further reads/assigns
            // share declaration block path.
            let assignList = blockList.concat();
            return vmap.set(name, {
              assign: assign,
              block: block,
              blockId: blockId,
              level: level,
              assignList: assignList
            });
          } else {
            // Read happened before assign, block-assign is already dead.
            return vmap.set(name, {
              killedBy: read,
              block: block,
              blockId: blockId,
              level: level
            });
          }
        }
      };
      this.variableDeclarationWalk({
        blockList: [],
        level: 0,
        blockId: 0,
        scope: scope,
        checkVar: checkVar
      });
      //console.log vmap
      return vmap.forEach(function(val) {
        if (!val.killedBy) {
          return val.assign.canDeclare = true;
        }
      });
    };

    Block.prototype.variableDeclarationWalk = function(opts) {
      // mutate outer opts so each block within scope can get unique id.
      opts.blockId++;
      let optsThis = Object.assign({}, opts);
      optsThis.level++;
      optsThis.block = this;
      optsThis.blockList = optsThis.blockList.concat(opts.blockId);
      //console.log 'Block::varDecWalk', optsThis.blockList
      return Block.__super__.variableDeclarationWalk.call(this, optsThis);
    };

    return Block;

  })(Base);

  // end Iced Additions
  //--------------------
  //### Literal
  // `Literal` is a base class for static values that can be passed through
  // directly into JavaScript without translation, such as: strings, numbers,
  // `true`, `false`, `null`...
  exports.Literal = Literal = (function(superClass1) {
    extend1(Literal, superClass1);

    function Literal(value1) {
      this.value = value1;
    }

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = function(name) {
      return name === this.value;
    };

    Literal.prototype.compileNode = function(o) {
      return [this.makeCode(this.value)];
    };

    Literal.prototype.toString = function() {
      return " " + (this.isStatement() ? Literal.__super__.toString.apply(this, arguments) : this.constructor.name) + ": " + this.value;
    };

    return Literal;

  })(Base);

  exports.NumberLiteral = NumberLiteral = (function(superClass1) {
    extend1(NumberLiteral, superClass1);

    function NumberLiteral() {
      return NumberLiteral.__super__.constructor.apply(this, arguments);
    }

    return NumberLiteral;

  })(Literal);

  exports.InfinityLiteral = InfinityLiteral = (function(superClass1) {
    extend1(InfinityLiteral, superClass1);

    function InfinityLiteral() {
      return InfinityLiteral.__super__.constructor.apply(this, arguments);
    }

    InfinityLiteral.prototype.compileNode = function() {
      return [this.makeCode('2e308')];
    };

    return InfinityLiteral;

  })(NumberLiteral);

  exports.NaNLiteral = NaNLiteral = (function(superClass1) {
    extend1(NaNLiteral, superClass1);

    function NaNLiteral() {
      NaNLiteral.__super__.constructor.call(this, 'NaN');
    }

    NaNLiteral.prototype.compileNode = function(o) {
      let code = [this.makeCode('0/0')];
      if (o.level >= LEVEL_OP) {
        return this.wrapInBraces(code);
      } else {
        return code;
      }
    };

    return NaNLiteral;

  })(NumberLiteral);

  exports.StringLiteral = StringLiteral = (function(superClass1) {
    extend1(StringLiteral, superClass1);

    function StringLiteral() {
      return StringLiteral.__super__.constructor.apply(this, arguments);
    }

    return StringLiteral;

  })(Literal);

  exports.RegexLiteral = RegexLiteral = (function(superClass1) {
    extend1(RegexLiteral, superClass1);

    function RegexLiteral() {
      return RegexLiteral.__super__.constructor.apply(this, arguments);
    }

    return RegexLiteral;

  })(Literal);

  exports.PassthroughLiteral = PassthroughLiteral = (function(superClass1) {
    extend1(PassthroughLiteral, superClass1);

    function PassthroughLiteral() {
      return PassthroughLiteral.__super__.constructor.apply(this, arguments);
    }

    return PassthroughLiteral;

  })(Literal);

  exports.IdentifierLiteral = IdentifierLiteral = (function(superClass1) {
    extend1(IdentifierLiteral, superClass1);

    function IdentifierLiteral() {
      return IdentifierLiteral.__super__.constructor.apply(this, arguments);
    }

    IdentifierLiteral.prototype.isAssignable = YES;

    //------
    // Begin Iced Additions...
    IdentifierLiteral.prototype.compileNode = function(o) {
      var ref3, ref4, ref5, ref6;
      if (this.value === 'arguments' && o.scope.icedUseArguments) {
        // TODO: Find a better way to supply icedArgumentsVar instead
        // of this scope madness.
        // If the generator function is bound:
        // bar = function(i, cb) {               # ~ PARENT 2
        //     var __iced_it, __iced_passed_deferral, _arguments;
        //     _arguments = arguments;
        //     __iced_passed_deferral = iced.findDeferral(arguments);
        //     __iced_it = (function(_this) {    # ~ PARENT 1
        //       return function*() {
        //           # ~ WE ARE HERE ~
        // When it's not, it's only one parent up.
        this.value = (ref3 = o.scope.parent) != null ? ref3.icedArgumentsVar : void 0;
        if (!this.value) {
          this.value = (ref4 = o.scope.parent) != null ? (ref5 = ref4.parent) != null ? ref5.icedArgumentsVar : void 0 : void 0;
          if (!this.value) {
            throw new Error("Compiler bug: failed to compile `arguments` inside of async func");
          }
        }
      }
      let code = this.value === 'this' ? ((ref6 = o.scope.method) != null ? ref6.bound : void 0) ? o.scope.method.context : this.value : this.value.reserved ? "\"" + this.value + "\"" : this.value === BUILTIN_ICED_VER_LITERAL ?  /* Using this "magic identifier" programs can test whether */  /* they are compiled using Iced3 compiler. */ "\"iced3\"" : this.value;
      let answer = this.isStatement() ? "" + this.tab + code + ";" : code;
      return [this.makeCode(answer)];
    };

    IdentifierLiteral.prototype.icedWalkAst = function(o) {
      IdentifierLiteral.__super__.icedWalkAst.call(this, o);
      // Check if any of the code references `arguments` variable
      // if we also have await construct. Arguments array will be
      // stored in temporary variable at the beginning of function.
      if (this.value === 'arguments') {
        o.foundArguments = true;
      }
      return this;
    };

    return IdentifierLiteral;

  })(Literal);

  // End Iced Additions...
  //------
  exports.PropertyName = PropertyName = (function(superClass1) {
    extend1(PropertyName, superClass1);

    function PropertyName() {
      return PropertyName.__super__.constructor.apply(this, arguments);
    }

    PropertyName.prototype.isAssignable = YES;

    return PropertyName;

  })(Literal);

  exports.StatementLiteral = StatementLiteral = (function(superClass1) {
    extend1(StatementLiteral, superClass1);

    function StatementLiteral() {
      return StatementLiteral.__super__.constructor.apply(this, arguments);
    }

    StatementLiteral.prototype.isStatement = YES;

    StatementLiteral.prototype.makeReturn = THIS;

    StatementLiteral.prototype.jumps = function(o) {
      if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
        return this;
      }
      if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {
        return this;
      }
    };

    StatementLiteral.prototype.compileNode = function(o) {
      return [this.makeCode("" + this.tab + this.value + ";")];
    };

    return StatementLiteral;

  })(Literal);

  exports.ThisLiteral = ThisLiteral = (function(superClass1) {
    extend1(ThisLiteral, superClass1);

    function ThisLiteral() {
      ThisLiteral.__super__.constructor.call(this, 'this');
    }

    ThisLiteral.prototype.compileNode = function(o) {
      var ref3;
      let code = ((ref3 = o.scope.method) != null ? ref3.bound : void 0) ? o.scope.method.context : this.value;
      return [this.makeCode(code)];
    };

    ThisLiteral.prototype.icedWalkAst = function(o) {
      ThisLiteral.__super__.icedWalkAst.call(this, o);
      o.foundThis = true;
      return this;
    };

    return ThisLiteral;

  })(Literal);

  exports.UndefinedLiteral = UndefinedLiteral = (function(superClass1) {
    extend1(UndefinedLiteral, superClass1);

    function UndefinedLiteral() {
      UndefinedLiteral.__super__.constructor.call(this, 'undefined');
    }

    UndefinedLiteral.prototype.compileNode = function(o) {
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
    };

    return UndefinedLiteral;

  })(Literal);

  exports.NullLiteral = NullLiteral = (function(superClass1) {
    extend1(NullLiteral, superClass1);

    function NullLiteral() {
      NullLiteral.__super__.constructor.call(this, 'null');
    }

    return NullLiteral;

  })(Literal);

  exports.BooleanLiteral = BooleanLiteral = (function(superClass1) {
    extend1(BooleanLiteral, superClass1);

    function BooleanLiteral() {
      return BooleanLiteral.__super__.constructor.apply(this, arguments);
    }

    return BooleanLiteral;

  })(Literal);

  //### Return
  // A `return` is a *pureStatement* -- wrapping it in a closure wouldn't
  // make sense.
  exports.Return = Return = (function(superClass1) {
    extend1(Return, superClass1);

    function Return(expression) {
      this.expression = expression;
    }

    Return.prototype.children = ['expression'];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compileToFragments = function(o, level) {
      var ref3;
      let expr = (ref3 = this.expression) != null ? ref3.makeReturn() : void 0;
      if (expr && !(expr instanceof Return)) {
        return expr.compileToFragments(o, level);
      } else {
        return Return.__super__.compileToFragments.call(this, o, level);
      }
    };

    Return.prototype.compileNode = function(o) {
      this.icedStatementAssertion();
      let answer = [];
      // TODO: If we call expression.compile() here twice, we'll sometimes get back different results!
      answer.push(this.makeCode(this.tab + ("return" + (this.expression ? " " : ""))));
      if (this.expression) {
        answer = answer.concat(this.expression.compileToFragments(o, LEVEL_PAREN));
      }
      answer.push(this.makeCode(";"));
      return answer;
    };

    return Return;

  })(Base);

  // `yield return` works exactly like `return`, except that it turns the function
  // into a generator.
  exports.YieldReturn = YieldReturn = (function(superClass1) {
    extend1(YieldReturn, superClass1);

    function YieldReturn() {
      return YieldReturn.__super__.constructor.apply(this, arguments);
    }

    YieldReturn.prototype.compileNode = function(o) {
      if (o.scope.parent == null) {
        this.error('yield can only occur inside functions');
      }
      return YieldReturn.__super__.compileNode.apply(this, arguments);
    };

    return YieldReturn;

  })(Return);

  //### Value
  // A value, variable or literal or parenthesized, indexed or dotted into,
  // or vanilla.
  exports.Value = Value = (function(superClass1) {
    extend1(Value, superClass1);

    function Value(base, props, tag) {
      if (!props && base instanceof Value) {
        return base;
      }
      this.base = base;
      this.properties = props || [];
      if (tag) {
        this[tag] = true;
      }
      return this;
    }

    Value.prototype.children = ['base', 'properties'];

    // Add a property (or *properties* ) `Access` to the list.
    Value.prototype.add = function(props) {
      this.properties = this.properties.concat(props);
      return this;
    };

    Value.prototype.hasProperties = function() {
      return !!this.properties.length;
    };

    Value.prototype.bareLiteral = function(type) {
      return !this.properties.length && this.base instanceof type;
    };

    // Some boolean checks for the benefit of other nodes.
    Value.prototype.isArray = function() {
      return this.bareLiteral(Arr);
    };

    Value.prototype.isRange = function() {
      return this.bareLiteral(Range);
    };

    Value.prototype.isComplex = function() {
      return this.hasProperties() || this.base.isComplex();
    };

    Value.prototype.isAssignable = function() {
      return this.hasProperties() || this.base.isAssignable();
    };

    Value.prototype.isNumber = function() {
      return this.bareLiteral(NumberLiteral);
    };

    Value.prototype.isString = function() {
      return this.bareLiteral(StringLiteral);
    };

    Value.prototype.isRegex = function() {
      return this.bareLiteral(RegexLiteral);
    };

    Value.prototype.isUndefined = function() {
      return this.bareLiteral(UndefinedLiteral);
    };

    Value.prototype.isNull = function() {
      return this.bareLiteral(NullLiteral);
    };

    Value.prototype.isBoolean = function() {
      return this.bareLiteral(BooleanLiteral);
    };

    Value.prototype.isAtomic = function() {
      var j, len1, node, ref3;
      ref3 = this.properties.concat(this.base);
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        node = ref3[j];
        if (node.soak || node instanceof Call) {
          return false;
        }
      }
      return true;
    };

    Value.prototype.isNotCallable = function() {
      return this.isNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject() || this.isUndefined() || this.isNull() || this.isBoolean();
    };

    Value.prototype.isStatement = function(o) {
      return !this.properties.length && this.base.isStatement(o);
    };

    Value.prototype.assigns = function(name) {
      return !this.properties.length && this.base.assigns(name);
    };

    Value.prototype.jumps = function(o) {
      return !this.properties.length && this.base.jumps(o);
    };

    Value.prototype.isObject = function(onlyGenerated) {
      if (this.properties.length) {
        return false;
      }
      return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);
    };

    Value.prototype.isSplice = function() {
      var lastProp, ref3;
      ref3 = this.properties, lastProp = ref3[ref3.length - 1];
      return lastProp instanceof Slice;
    };

    Value.prototype.looksStatic = function(className) {
      var ref3;
      return this.base.value === className && this.properties.length === 1 && ((ref3 = this.properties[0].name) != null ? ref3.value : void 0) !== 'prototype';
    };

    // The value can be unwrapped as its inner node, if there are no attached
    // properties.
    Value.prototype.unwrap = function() {
      if (this.properties.length) {
        return this;
      } else {
        return this.base;
      }
    };

    // A reference has base part (`this` value) and name part.
    // We cache them separately for compiling complex expressions.
    // `a()[b()] ?= c` -> `(_base = a())[_name = b()] ? _base[_name] = c`
    Value.prototype.cacheReference = function(o) {
      var bref, name, nref, ref3;
      ref3 = this.properties, name = ref3[ref3.length - 1];
      if (this.properties.length < 2 && !this.base.isComplex() && !(name != null ? name.isComplex() : void 0)) {
        return [this, this];
      }
      // `a` `a.b`
      let base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) {
        // `a().b`
        bref = new IdentifierLiteral(o.scope.freeVariable('base'));
        base = new Value(new Parens(new Assign(bref, base)));
      }
      if (!name) {
        return [base, bref];
      }
      // `a()`
      if (name.isComplex()) {
        // `a[b()]`
        nref = new IdentifierLiteral(o.scope.freeVariable('name'));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
      }
      return [base.add(name), new Value(bref || base.base, [nref || name])];
    };

    // We compile a value to JavaScript by compiling and joining each property.
    // Things get much more interesting if the chain of properties has *soak*
    // operators `?.` interspersed. Then we have to take care not to accidentally
    // evaluate anything twice when building the soak chain.
    Value.prototype.compileNode = function(o) {
      var j, len1, prop;
      this.base.front = this.front;
      let props = this.properties;
      let fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));
      if (props.length && SIMPLENUM.test(fragmentsToText(fragments))) {
        fragments.push(this.makeCode('.'));
      }
      for (j = 0, len1 = props.length; j < len1; j++) {
        prop = props[j];
        fragments.push.apply(fragments, prop.compileToFragments(o));
      }
      return fragments;
    };

    // Unfold a soak into an `If`: `a?.b` -> `a.b if a?`
    Value.prototype.unfoldSoak = function(o) {
      return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (function(_this) {
        return function() {
          var i, ifn, j, len1, prop, ref3, ref4;
          if (ifn = _this.base.unfoldSoak(o)) {
            (ref3 = ifn.body.properties).push.apply(ref3, _this.properties);
            return ifn;
          }
          ref4 = _this.properties;
          for (i = j = 0, len1 = ref4.length; j < len1; i = ++j) {
            prop = ref4[i];
            if (!prop.soak) {
              continue;
            }
            prop.soak = false;
            let fst = new Value(_this.base, _this.properties.slice(0, i));
            let snd = new Value(_this.base, _this.properties.slice(i));
            if (fst.isComplex()) {
              let ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
          return false;
        };
      })(this)();
    };

    // If this value is being used as a slot for the purposes of a defer
    // then export it here
    Value.prototype.icedToSlot = function(i) {
      var suffix;
      if (this.base instanceof Obj) {
        return this.base.icedToSlot(i);
      }
      let sufffix = null;
      if (this.properties && this.properties.length) {
        suffix = this.properties.pop();
      }
      return new Slot(i, this, suffix);
    };

    Value.prototype.icedToSlotAccess = function() {
      // See bug #78 in the ICS repository. We're concerned about this case:
      //    await foo defer { @x }
      // In this situation, `@x` will be represented as a value with the `this`
      // property set to `true`, and properties[0] will have the name of the
      // dictionary key that's needed (already as an `Access` instance)
      if (this["this"]) {
        return this.properties[0];
      } else {
        return new Access(new PropertyName(this.base.value));
      }
    };

    // Minor iced addition for convenience
    Value.prototype.copy = function() {
      return new Value(this.base, this.properties);
    };

    Value.prototype.variableDeclarationWalk = function(opts) {
      //console.log 'Value::varDec', @isAssignable(), @base.value, @toStringCompact()
      var v;
      if (this.isAssignable() && (v = this.base.value)) {
        return opts.checkVar(v, opts, {
          read: this
        });
      } else {
        return Value.__super__.variableDeclarationWalk.apply(this, arguments);
      }
    };

    return Value;

  })(Base);

  //### Comment
  // CoffeeScript passes through block comments as JavaScript block comments
  // at the same position.
  exports.Comment = Comment = (function(superClass1) {
    extend1(Comment, superClass1);

    function Comment(comment1) {
      this.comment = comment1;
    }

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.sticky = YES;

    Comment.prototype.isTypeComment = function() {
      return this.comment.trimStart().startsWith('@type');
    };

    Comment.prototype.compileNode = function(o, level) {
      var code;
      let multiline = indexOf.call(this.comment, '\n') >= 0;
      if (multiline) {
        let comment = this.comment.replace(/^(\s*)#(?=\s)/gm, "$1 *");
        code = "/*" + (multident(comment, this.tab)) + "\n" + this.tab + " */";
      } else {
        code = "//" + this.comment;
      }
      if ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      if (multiline) {
        return [this.makeCode("\n"), this.makeCode(code)];
      } else {
        return [this.makeCode(code)];
      }
    };

    return Comment;

  })(Base);

  //### Call
  // Node for a function invocation.
  exports.Call = Call = (function(superClass1) {
    extend1(Call, superClass1);

    function Call(variable1, args1, soak1) {
      this.variable = variable1;
      this.args = args1 != null ? args1 : [];
      this.soak = soak1;
      this.isNew = false;
      if (this.variable instanceof Value && this.variable.isNotCallable()) {
        this.variable.error("literal is not a function");
      }
    }

    Call.prototype.children = ['variable', 'args'];

    // When setting the location, we sometimes need to update the start location to
    // account for a newly-discovered `new` operator to the left of us. This
    // expands the range on the left, but not the right.
    Call.prototype.updateLocationDataIfMissing = function(locationData) {
      var ref3;
      if (this.locationData && this.needsUpdatedStartLocation) {
        this.locationData.first_line = locationData.first_line;
        this.locationData.first_column = locationData.first_column;
        let base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
        if (base.needsUpdatedStartLocation) {
          this.variable.locationData.first_line = locationData.first_line;
          this.variable.locationData.first_column = locationData.first_column;
          base.updateLocationDataIfMissing(locationData);
        }
        delete this.needsUpdatedStartLocation;
      }
      return Call.__super__.updateLocationDataIfMissing.apply(this, arguments);
    };

    // Tag this invocation as creating a new instance.
    Call.prototype.newInstance = function() {
      var ref3;
      let base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
      if (base instanceof Call && !base.isNew) {
        base.newInstance();
      } else {
        this.isNew = true;
      }
      this.needsUpdatedStartLocation = true;
      return this;
    };

    // Soaked chained invocations unfold into if/else ternary structures.
    Call.prototype.unfoldSoak = function(o) {
      var ifn, j, left, len1, ref3, ref4, rite;
      if (this.soak) {
        if (this instanceof SuperCall) {
          left = new Literal(this.superReference(o));
          rite = new Value(left);
        } else {
          if (ifn = unfoldSoak(o, this, 'variable')) {
            return ifn;
          }
          ref3 = new Value(this.variable).cacheReference(o), left = ref3[0], rite = ref3[1];
        }
        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal("typeof " + (left.compile(o)) + " === \"function\"");
        return new If(left, new Value(rite), {
          soak: true
        });
      }
      let call = this;
      let list = [];
      while (true) {
        if (call.variable instanceof Call) {
          list.push(call);
          call = call.variable;
          continue;
        }
        if (!(call.variable instanceof Value)) {
          break;
        }
        list.push(call);
        if (!((call = call.variable.base) instanceof Call)) {
          break;
        }
      }
      ref4 = list.reverse();
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        call = ref4[j];
        if (ifn) {
          if (call.variable instanceof Call) {
            call.variable = ifn;
          } else {
            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, 'variable');
      }
      return ifn;
    };

    // Compile a vanilla function call.
    Call.prototype.compileNode = function(o) {
      var arg, argIndex, j, len1, ref3, ref4;
      this.icedStatementAssertion();
      if ((ref3 = this.variable) != null) {
        ref3.front = this.front;
      }
      let compiledArray = Splat.compileSplattedArray(o, this.args, true);
      if (compiledArray.length) {
        return this.compileSplat(o, compiledArray);
      }
      let compiledArgs = [];
      ref4 = this.args;
      for (argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j) {
        arg = ref4[argIndex];
        if (argIndex) {
          compiledArgs.push(this.makeCode(", "));
        }
        compiledArgs.push.apply(compiledArgs, arg.compileToFragments(o, LEVEL_LIST));
      }
      let fragments = [];
      if (this instanceof SuperCall) {
        let preface = this.superReference(o) + (".call(" + (this.superThis(o)));
        if (compiledArgs.length) {
          preface += ", ";
        }
        fragments.push(this.makeCode(preface));
      } else {
        if (this.isNew) {
          fragments.push(this.makeCode('new '));
        }
        fragments.push.apply(fragments, this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode("("));
      }
      fragments.push.apply(fragments, compiledArgs);
      fragments.push(this.makeCode(")"));
      return fragments;
    };

    // If you call a function with a splat, it's converted into a JavaScript
    // `.apply()` call to allow an array of arguments to be passed.
    // If it's a constructor, then things get real tricky. We have to inject an
    // inner constructor in order to be able to pass the varargs.
    //
    // splatArgs is an array of CodeFragments to put into the 'apply'.
    Call.prototype.compileSplat = function(o, splatArgs) {
      var name, ref;
      if (this instanceof SuperCall) {
        return [].concat(this.makeCode((this.superReference(o)) + ".apply(" + (this.superThis(o)) + ", "), splatArgs, this.makeCode(")"));
      }
      if (this.isNew) {
        let idt = this.tab + TAB;
        return [].concat(this.makeCode("(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args);\n" + idt + "return Object(result) === result ? result : child;\n" + this.tab + "})("), this.variable.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), splatArgs, this.makeCode(", function(){})"));
      }
      let answer = [];
      let base = new Value(this.variable);
      if ((name = base.properties.pop()) && base.isComplex()) {
        ref = o.scope.freeVariable('ref');
        answer = answer.concat(this.makeCode("(" + ref + " = "), base.compileToFragments(o, LEVEL_LIST), this.makeCode(")"), name.compileToFragments(o));
      } else {
        let fun = base.compileToFragments(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fragmentsToText(fun))) {
          fun = this.wrapInBraces(fun);
        }
        if (name) {
          ref = fragmentsToText(fun);
          fun.push.apply(fun, name.compileToFragments(o));
        } else {
          ref = 'null';
        }
        answer = answer.concat(fun);
      }
      return answer = answer.concat(this.makeCode(".apply(" + ref + ", "), splatArgs, this.makeCode(")"));
    };

    Call.prototype.icedToSlot = function() {
      return this.error("function call cannot be a slot for defer");
    };

    return Call;

  })(Base);

  //### Super
  // Takes care of converting `super()` calls into calls against the prototype's
  // function of the same name.
  exports.SuperCall = SuperCall = (function(superClass1) {
    extend1(SuperCall, superClass1);

    function SuperCall(args) {
      SuperCall.__super__.constructor.call(this, null, args != null ? args : [new Splat(new IdentifierLiteral('arguments'))]);
      // Allow to recognize a bare `super` call without parentheses and arguments.
      this.isBare = args != null;
    }

    // Grab the reference to the superclass's implementation of the current
    // method.
    SuperCall.prototype.superReference = function(o) {
      var bref, klass, name, nref, variable;
      let method = o.scope.namedMethod();
      if (method != null ? method.klass : void 0) {
        klass = method.klass, name = method.name, variable = method.variable;
        if (klass.isComplex()) {
          bref = new IdentifierLiteral(o.scope.parent.freeVariable('base'));
          let base = new Value(new Parens(new Assign(bref, klass)));
          variable.base = base;
          variable.properties.splice(0, klass.properties.length);
        }
        if (name.isComplex() || (name instanceof Index && name.index.isAssignable())) {
          nref = new IdentifierLiteral(o.scope.parent.freeVariable('name'));
          name = new Index(new Assign(nref, name.index));
          variable.properties.pop();
          variable.properties.push(name);
        }
        let accesses = [new Access(new PropertyName('__super__'))];
        if (method["static"]) {
          accesses.push(new Access(new PropertyName('constructor')));
        }
        accesses.push(nref != null ? new Index(nref) : name);
        return (new Value(bref != null ? bref : klass, accesses)).compile(o);
      } else if (method != null ? method.ctor : void 0) {
        return method.name + ".__super__.constructor";
      } else {
        return this.error('cannot call super outside of an instance method.');
      }
    };

    // The appropriate `this` value for a `super` call.
    SuperCall.prototype.superThis = function(o) {
      let method = o.scope.method;
      return (method && !method.klass && method.context) || "this";
    };

    SuperCall.prototype.icedWalkAst = function(o) {
      SuperCall.__super__.icedWalkAst.call(this, o);
      o.foundThis = true;
      return this;
    };

    return SuperCall;

  })(Call);

  //### RegexWithInterpolations
  // Regexes with interpolations are in fact just a variation of a `Call` (a
  // `RegExp()` call to be precise) with a `StringWithInterpolations` inside.
  exports.RegexWithInterpolations = RegexWithInterpolations = (function(superClass1) {
    extend1(RegexWithInterpolations, superClass1);

    function RegexWithInterpolations(args) {
      if (args == null) {
        args = [];
      }
      RegexWithInterpolations.__super__.constructor.call(this, new Value(new IdentifierLiteral('RegExp')), args, false);
    }

    return RegexWithInterpolations;

  })(Call);

  //### TaggedTemplateCall
  exports.TaggedTemplateCall = TaggedTemplateCall = (function(superClass1) {
    extend1(TaggedTemplateCall, superClass1);

    function TaggedTemplateCall(variable, arg, soak) {
      if (arg instanceof StringLiteral) {
        arg = new StringWithInterpolations(Block.wrap([new Value(arg)]));
      }
      TaggedTemplateCall.__super__.constructor.call(this, variable, [arg], soak);
    }

    TaggedTemplateCall.prototype.compileNode = function(o) {
      // Tell `StringWithInterpolations` whether to compile as ES2015 or not; will be removed in CoffeeScript 2.
      o.inTaggedTemplateCall = true;
      return this.variable.compileToFragments(o, LEVEL_ACCESS).concat(this.args[0].compileToFragments(o, LEVEL_LIST));
    };

    return TaggedTemplateCall;

  })(Call);

  //### Extends
  // Node to extend an object's prototype with an ancestor object.
  // After `goog.inherits` from the
  // [Closure Library](https://github.com/google/closure-library/blob/master/closure/goog/base.js).
  exports.Extends = Extends = (function(superClass1) {
    extend1(Extends, superClass1);

    function Extends(child1, parent1) {
      this.child = child1;
      this.parent = parent1;
    }

    Extends.prototype.children = ['child', 'parent'];

    // Hooks one constructor into another's prototype chain.
    Extends.prototype.compileToFragments = function(o) {
      return new Call(new Value(new Literal(utility('extend', o))), [this.child, this.parent]).compileToFragments(o);
    };

    return Extends;

  })(Base);

  //### Access
  // A `.` access into a property of a value, or the `::` shorthand for
  // an access into the object's prototype.
  exports.Access = Access = (function(superClass1) {
    extend1(Access, superClass1);

    function Access(name1, tag) {
      this.name = name1;
      this.soak = tag === 'soak';
    }

    Access.prototype.children = ['name'];

    Access.prototype.compileToFragments = function(o) {
      var ref3;
      let name = this.name.compileToFragments(o);
      let node = this.name.unwrap();
      if (node instanceof PropertyName || node instanceof Defer) {
        if (ref3 = node.value, indexOf.call(JS_FORBIDDEN, ref3) >= 0) {
          return [this.makeCode('["')].concat(slice.call(name), [this.makeCode('"]')]);
        } else {
          return [this.makeCode('.')].concat(slice.call(name));
        }
      } else {
        return [this.makeCode('[')].concat(slice.call(name), [this.makeCode(']')]);
      }
    };

    Access.prototype.isComplex = NO;

    return Access;

  })(Base);

  //### Index
  // A `[ ... ]` indexed access into an array or object.
  exports.Index = Index = (function(superClass1) {
    extend1(Index, superClass1);

    function Index(index1) {
      this.index = index1;
    }

    Index.prototype.children = ['index'];

    Index.prototype.compileToFragments = function(o) {
      return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
    };

    Index.prototype.isComplex = function() {
      return this.index.isComplex();
    };

    return Index;

  })(Base);

  //### Range
  // A range literal. Ranges can be used to extract portions (slices) of arrays,
  // to specify a range for comprehensions, or as a value, to be expanded into the
  // corresponding array of integers at runtime.
  exports.Range = Range = (function(superClass1) {
    extend1(Range, superClass1);

    Range.prototype.children = ['from', 'to'];

    function Range(from1, to1, tag) {
      this.from = from1;
      this.to = to1;
      this.exclusive = tag === 'exclusive';
      this.equals = this.exclusive ? '' : '=';
    }

    // Compiles the range's source variables -- where it starts and where it ends.
    // But only if they need to be cached to avoid double evaluation.
    Range.prototype.compileVariables = function(o) {
      var ref3, ref4, ref5, step;
      o = merge(o, {
        top: true
      });
      let isComplex = del(o, 'isComplex');
      ref3 = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, isComplex)), this.fromC = ref3[0], this.fromVar = ref3[1];
      ref4 = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, isComplex)), this.toC = ref4[0], this.toVar = ref4[1];
      if (step = del(o, 'step')) {
        ref5 = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, isComplex)), this.step = ref5[0], this.stepVar = ref5[1];
      }
      this.fromNum = this.from.isNumber() ? Number(this.fromVar) : null;
      this.toNum = this.to.isNumber() ? Number(this.toVar) : null;
      return this.stepNum = (step != null ? step.isNumber() : void 0) ? Number(this.stepVar) : null;
    };

    // When compiled normally, the range returns the contents of the *for loop*
    // needed to iterate over the values in the range. Used by comprehensions.
    Range.prototype.compileNode = function(o) {
      var cond, from, gt, lt, ref3, ref4, to;
      if (!this.fromVar) {
        this.compileVariables(o);
      }
      if (!o.index) {
        return this.compileArray(o);
      }
      // Set up endpoints.
      let known = (this.fromNum != null) && (this.toNum != null);
      let idx = del(o, 'index');
      let idxName = del(o, 'name');
      let namedIndex = idxName && idxName !== idx;
      let varPart = idx + " = " + this.fromC;
      if (this.toC !== this.toVar) {
        varPart += ", " + this.toC;
      }
      if (this.step !== this.stepVar) {
        varPart += ", " + this.step;
      }
      ref3 = [idx + " <" + this.equals, idx + " >" + this.equals], lt = ref3[0], gt = ref3[1];
      // Generate the condition.
      let condPart = this.stepNum != null ? this.stepNum > 0 ? lt + " " + this.toVar : gt + " " + this.toVar : known ? ((ref4 = [this.fromNum, this.toNum], from = ref4[0], to = ref4[1], ref4), from <= to ? lt + " " + to : gt + " " + to) : (cond = this.stepVar ? this.stepVar + " > 0" : this.fromVar + " <= " + this.toVar, cond + " ? " + lt + " " + this.toVar + " : " + gt + " " + this.toVar);
      // Generate the step.
      let stepPart = this.stepVar ? idx + " += " + this.stepVar : known ? namedIndex ? from <= to ? "++" + idx : "--" + idx : from <= to ? idx + "++" : idx + "--" : namedIndex ? cond + " ? ++" + idx + " : --" + idx : cond + " ? " + idx + "++ : " + idx + "--";
      if (namedIndex) {
        varPart = idxName + " = " + varPart;
      }
      if (namedIndex) {
        stepPart = idxName + " = " + stepPart;
      }
      // The final loop body.
      return [this.makeCode(varPart + "; " + condPart + "; " + stepPart)];
    };

    // When used as a value, expand the range into the equivalent array.
    Range.prototype.compileArray = function(o) {
      var args, body, j, ref3, ref4, results;
      let known = (this.fromNum != null) && (this.toNum != null);
      if (known && Math.abs(this.fromNum - this.toNum) <= 20) {
        let range = (function() {
          results = [];
          for (var j = ref3 = this.fromNum, ref4 = this.toNum; ref3 <= ref4 ? j <= ref4 : j >= ref4; ref3 <= ref4 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this);
        if (this.exclusive) {
          range.pop();
        }
        return [this.makeCode("[" + (range.join(', ')) + "]")];
      }
      let idt = this.tab + TAB;
      let i = o.scope.freeVariable('i', {
        single: true
      });
      let result = o.scope.freeVariable('results');
      let pre = "\n" + idt + result + " = [];";
      if (known) {
        o.index = i;
        body = fragmentsToText(this.compileNode(o));
      } else {
        let vars = (i + " = " + this.fromC) + (this.toC !== this.toVar ? ", " + this.toC : '');
        let cond = this.fromVar + " <= " + this.toVar;
        body = "var " + vars + "; " + cond + " ? " + i + " <" + this.equals + " " + this.toVar + " : " + i + " >" + this.equals + " " + this.toVar + "; " + cond + " ? " + i + "++ : " + i + "--";
      }
      let post = "{ " + result + ".push(" + i + "); }\n" + idt + "return " + result + ";\n" + o.indent;
      let hasArgs = function(node) {
        return node != null ? node.contains(isLiteralArguments) : void 0;
      };
      if (hasArgs(this.from) || hasArgs(this.to)) {
        args = ', arguments';
      }
      return [this.makeCode("(function() {" + pre + "\n" + idt + "for (" + body + ")" + post + "}).apply(this" + (args != null ? args : '') + ")")];
    };

    return Range;

  })(Base);

  //### Slice
  // An array slice literal. Unlike JavaScript's `Array#slice`, the second parameter
  // specifies the index of the end of the slice, just as the first parameter
  // is the index of the beginning.
  exports.Slice = Slice = (function(superClass1) {
    extend1(Slice, superClass1);

    Slice.prototype.children = ['range'];

    function Slice(range1) {
      this.range = range1;
      Slice.__super__.constructor.call(this);
    }

    // We have to be careful when trying to slice through the end of the array,
    // `9e9` is used because not all implementations respect `undefined` or `1/0`.
    // `9e9` should be safe because `9e9` > `2**32`, the max array length.
    Slice.prototype.compileNode = function(o) {
      var from, ref3, to, toStr;
      ref3 = this.range, to = ref3.to, from = ref3.from;
      let fromCompiled = from && from.compileToFragments(o, LEVEL_PAREN) || [this.makeCode('0')];
      // TODO: jwalton - move this into the 'if'?
      if (to) {
        let compiled = to.compileToFragments(o, LEVEL_PAREN);
        let compiledText = fragmentsToText(compiled);
        if (!(!this.range.exclusive && +compiledText === -1)) {
          toStr = ', ' + (this.range.exclusive ? compiledText : to.isNumber() ? "" + (+compiledText + 1) : (compiled = to.compileToFragments(o, LEVEL_ACCESS), "+" + (fragmentsToText(compiled)) + " + 1 || 9e9"));
        }
      }
      return [this.makeCode(".slice(" + (fragmentsToText(fromCompiled)) + (toStr || '') + ")")];
    };

    return Slice;

  })(Base);

  //### Obj
  // An object literal, nothing fancy.
  exports.Obj = Obj = (function(superClass1) {
    extend1(Obj, superClass1);

    function Obj(props, generated) {
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
    }

    Obj.prototype.children = ['properties'];

    Obj.prototype.compileNode = function(o) {
      var dynamicIndex, i, j, k, key, len1, len2, len3, m, node, oref, prop, ref3, value;
      let props = this.properties;
      if (this.generated) {
        for (j = 0, len1 = props.length; j < len1; j++) {
          node = props[j];
          if (node instanceof Value) {
            node.error('cannot have an implicit value in an implicit object');
          }
        }
      }
      for (dynamicIndex = k = 0, len2 = props.length; k < len2; dynamicIndex = ++k) {
        prop = props[dynamicIndex];
        if ((prop.variable || prop).base instanceof Parens) {
          break;
        }
      }
      let hasDynamic = dynamicIndex < props.length;
      let idt = o.indent += TAB;
      let lastNoncom = this.lastNonComment(this.properties);
      let answer = [];
      if (hasDynamic) {
        oref = o.scope.freeVariable('obj');
        answer.push(this.makeCode("(\n" + idt + oref + " = "));
      }
      answer.push(this.makeCode("{" + (props.length === 0 || dynamicIndex === 0 ? '}' : '\n')));
      for (i = m = 0, len3 = props.length; m < len3; i = ++m) {
        prop = props[i];
        if (i === dynamicIndex) {
          if (i !== 0) {
            answer.push(this.makeCode("\n" + idt + "}"));
          }
          answer.push(this.makeCode(',\n'));
        }
        let join = i === props.length - 1 || i === dynamicIndex - 1 ? '' : prop === lastNoncom || prop instanceof Comment ? '\n' : ',\n';
        let indent = prop instanceof Comment ? '' : idt;
        if (hasDynamic && i < dynamicIndex) {
          indent += TAB;
        }
        if (prop instanceof Assign) {
          if (prop.context !== 'object') {
            prop.operatorToken.error("unexpected " + prop.operatorToken.value);
          }
          if (prop.variable instanceof Value && prop.variable.hasProperties()) {
            prop.variable.error('invalid object key');
          }
        }
        if (prop instanceof Value && prop["this"]) {
          prop = new Assign(prop.properties[0].name, prop, 'object');
        }
        if (!(prop instanceof Comment)) {
          if (i < dynamicIndex) {
            if (!(prop instanceof Assign)) {
              prop = new Assign(prop, prop, 'object');
            }
          } else {
            if (prop instanceof Assign) {
              key = prop.variable;
              value = prop.value;
            } else {
              ref3 = prop.base.cache(o), key = ref3[0], value = ref3[1];
              if (key instanceof IdentifierLiteral) {
                key = new PropertyName(key.value);
              }
            }
            prop = new Assign(new Value(new IdentifierLiteral(oref), [new Access(key)]), value);
          }
        }
        if (indent) {
          answer.push(this.makeCode(indent));
        }
        answer.push.apply(answer, prop.compileToFragments(o, LEVEL_TOP));
        if (join) {
          answer.push(this.makeCode(join));
        }
      }
      if (hasDynamic) {
        answer.push(this.makeCode(",\n" + idt + oref + "\n" + this.tab + ")"));
      } else {
        if (props.length !== 0) {
          answer.push(this.makeCode("\n" + this.tab + "}"));
        }
      }
      if (this.front && !hasDynamic) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Obj.prototype.assigns = function(name) {
      var j, len1, prop, ref3;
      ref3 = this.properties;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        prop = ref3[j];
        if (prop.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    Obj.prototype.icedToSlot = function(i) {
      var j, len1, prop, ref3, results;
      ref3 = this.properties;
      results = [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        prop = ref3[j];
        if (prop instanceof Assign) {
          results.push((prop.value.icedToSlot(i)).addAccess(prop.variable.icedToSlotAccess()));
        } else if (prop instanceof Value) {
          let access = prop.icedToSlotAccess();
          results.push((prop.icedToSlot(i)).addAccess(access));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Obj;

  })(Base);

  //### Arr
  // An array literal.
  exports.Arr = Arr = (function(superClass1) {
    extend1(Arr, superClass1);

    function Arr(objs) {
      this.objects = objs || [];
    }

    Arr.prototype.children = ['objects'];

    Arr.prototype.compileNode = function(o) {
      var fragments, index, j, len1, obj;
      if (!this.objects.length) {
        return [this.makeCode('[]')];
      }
      o.indent += TAB;
      let answer = Splat.compileSplattedArray(o, this.objects);
      if (answer.length) {
        return answer;
      }
      answer = [];
      let compiledObjs = (function() {
        var j, len1, ref3, results;
        ref3 = this.objects;
        results = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          obj = ref3[j];
          results.push(obj.compileToFragments(o, LEVEL_LIST));
        }
        return results;
      }).call(this);
      for (index = j = 0, len1 = compiledObjs.length; j < len1; index = ++j) {
        fragments = compiledObjs[index];
        if (index) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, fragments);
      }
      if (fragmentsToText(answer).indexOf('\n') >= 0) {
        answer.unshift(this.makeCode("[\n" + o.indent));
        answer.push(this.makeCode("\n" + this.tab + "]"));
      } else {
        answer.unshift(this.makeCode("["));
        answer.push(this.makeCode("]"));
      }
      return answer;
    };

    Arr.prototype.assigns = function(name) {
      var j, len1, obj, ref3;
      ref3 = this.objects;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        obj = ref3[j];
        if (obj.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Arr;

  })(Base);

  //### Class
  // The CoffeeScript class definition.
  // Initialize a **Class** with its name, an optional superclass, and a
  // list of prototype property assignments.
  exports.Class = Class = (function(superClass1) {
    extend1(Class, superClass1);

    function Class(variable1, parent1, body1) {
      this.variable = variable1;
      this.parent = parent1;
      this.body = body1 != null ? body1 : new Block;
      this.boundFuncs = [];
      this.body.classBody = true;
    }

    Class.prototype.children = ['variable', 'parent', 'body'];

    Class.prototype.defaultClassVariableName = '_Class';

    // Figure out the appropriate name for the constructor function of this class.
    Class.prototype.determineName = function() {
      var ref3, tail;
      if (!this.variable) {
        return this.defaultClassVariableName;
      }
      ref3 = this.variable.properties, tail = ref3[ref3.length - 1];
      let node = tail ? tail instanceof Access && tail.name : this.variable.base;
      if (!(node instanceof IdentifierLiteral || node instanceof PropertyName)) {
        return this.defaultClassVariableName;
      }
      let name = node.value;
      if (!tail) {
        let message = isUnassignable(name);
        if (message) {
          this.variable.error(message);
        }
      }
      if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
        return "_" + name;
      } else {
        return name;
      }
    };

    // For all `this`-references and bound functions in the class definition,
    // `this` is the Class being constructed.
    Class.prototype.setContext = function(name) {
      return this.body.traverseChildren(false, function(node) {
        if (node.classBody) {
          return false;
        }
        if (node instanceof ThisLiteral) {
          return node.value = name;
        } else if (node instanceof Code) {
          if (node.bound) {
            return node.context = name;
          }
        }
      });
    };

    // Ensure that all functions bound to the instance are proxied in the
    // constructor.
    Class.prototype.addBoundFunctions = function(o) {
      var bvar, j, len1, ref3;
      ref3 = this.boundFuncs;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        bvar = ref3[j];
        let lhs = (new Value(new ThisLiteral, [new Access(bvar)])).compile(o);
        this.ctor.body.unshift(new Literal(lhs + " = " + (utility('bind', o)) + "(" + lhs + ", this)"));
      }
    };

    // Merge the properties from a top-level object as prototypal properties
    // on the class.
    Class.prototype.addProperties = function(node, name, o) {
      var assign;
      let props = node.base.properties.slice(0);
      let exprs = (function() {
        var results;
        results = [];
        while (assign = props.shift()) {
          if (assign instanceof Assign) {
            let locData = assign.locationData;
            let base = assign.variable.base;
            delete assign.context;
            let func = assign.value;
            if (base.value === 'constructor') {
              if (this.ctor) {
                assign.error('cannot define more than one constructor in a class');
              }
              if (func.bound) {
                assign.error('cannot define a constructor as a bound function');
              }
              if (func instanceof Code) {
                assign = this.ctor = func;
              } else {
                this.externalCtor = o.classScope.freeVariable('ctor');
                assign = new Assign(new IdentifierLiteral(this.externalCtor), func);
                assign.updateLocationDataIfMissing(locData);
              }
            } else {
              if (assign.variable["this"]) {
                func["static"] = true;
              } else {
                let acc = base.isComplex() ? new Index(base) : new Access(base);
                assign.variable = new Value(new IdentifierLiteral(name), [new Access(new PropertyName('prototype')), acc]);
                assign.variable.updateLocationDataIfMissing(locData);
                if (func instanceof Code && func.bound) {
                  this.boundFuncs.push(base);
                  func.bound = false;
                }
              }
            }
          }
          results.push(assign);
        }
        return results;
      }).call(this);
      return compact(exprs);
    };

    // Walk the body of the class, looking for prototype properties to be converted
    // and tagging static assignments.
    Class.prototype.walkBody = function(name, o) {
      return this.traverseChildren(false, (function(_this) {
        return function(child) {
          var exps, i, j, len1, node, ref3;
          let cont = true;
          if (child instanceof Class) {
            return false;
          }
          if (child instanceof Block) {
            ref3 = exps = child.expressions;
            for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) {
              node = ref3[i];
              if (node instanceof Assign && node.variable.looksStatic(name)) {
                node.value["static"] = true;
              } else if (node instanceof Value && node.isObject(true)) {
                cont = false;
                exps[i] = _this.addProperties(node, name, o);
              }
              // Preserve class for class private functions for better trace names.
              if (node instanceof Assign && !node.value["static"]) {
                node.value.icedPrivateOfCls = _this.variable;
              }
            }
            child.expressions = exps = flatten(exps);
          }
          return cont && !(child instanceof Class);
        };
      })(this));
    };

    // `use strict` (and other directives) must be the first expression statement(s)
    // of a function body. This method ensures the prologue is correctly positioned
    // above the `constructor`.
    Class.prototype.hoistDirectivePrologue = function() {
      var expressions, node;
      let index = 0;
      expressions = this.body.expressions;
      while ((node = expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()) {
        ++index;
      }
      return this.directives = expressions.splice(0, index);
    };

    // Make sure that a constructor is defined for the class, and properly
    // configured.
    Class.prototype.ensureConstructor = function(name) {
      if (!this.ctor) {
        this.ctor = new Code;
        if (this.externalCtor) {
          this.ctor.body.push(new Literal(this.externalCtor + ".apply(this, arguments)"));
        } else if (this.parent) {
          this.ctor.body.push(new Literal(name + ".__super__.constructor.apply(this, arguments)"));
        }
        this.ctor.body.makeReturn();
        this.body.expressions.unshift(this.ctor);
      }
      this.ctor.ctor = this.ctor.name = name;
      this.ctor.klass = null;
      return this.ctor.noReturn = true;
    };

    // Instead of generating the JavaScript string directly, we build up the
    // equivalent syntax tree and compile that, in pieces. You can see the
    // constructor, property assignments, and inheritance getting built out below.
    Class.prototype.compileNode = function(o) {
      var argumentsNode, jumpNode, ref3;
      if (jumpNode = this.body.jumps()) {
        jumpNode.error('Class bodies cannot contain pure statements');
      }
      if (argumentsNode = this.body.contains(isLiteralArguments)) {
        argumentsNode.error("Class bodies shouldn't reference arguments");
      }
      let name = this.determineName();
      let lname = new IdentifierLiteral(name);
      let func = new Code([], Block.wrap([this.body]));
      let args = [];
      o.classScope = func.makeScope(o.scope);
      this.hoistDirectivePrologue();
      this.setContext(name);
      this.walkBody(name, o);
      this.ensureConstructor(name);
      this.addBoundFunctions(o);
      this.body.spaced = true;
      this.body.expressions.push(lname);
      if (this.parent) {
        let superClass = new IdentifierLiteral(o.classScope.freeVariable('superClass', {
          reserve: false
        }));
        this.body.expressions.unshift(new Extends(lname, superClass));
        func.params.push(new Param(superClass));
        args.push(this.parent);
      }
      (ref3 = this.body.expressions).unshift.apply(ref3, this.directives);
      let klass = new Parens(new Call(func, args));
      if (this.variable) {
        klass = new Assign(this.variable, klass, null, {
          moduleDeclaration: this.moduleDeclaration
        });
      }
      return klass.compileToFragments(o);
    };

    return Class;

  })(Base);

  //### Import and Export
  exports.ModuleDeclaration = ModuleDeclaration = (function(superClass1) {
    extend1(ModuleDeclaration, superClass1);

    function ModuleDeclaration(clause, source1) {
      this.clause = clause;
      this.source = source1;
      this.checkSource();
    }

    ModuleDeclaration.prototype.children = ['clause', 'source'];

    ModuleDeclaration.prototype.isStatement = YES;

    ModuleDeclaration.prototype.jumps = THIS;

    ModuleDeclaration.prototype.makeReturn = THIS;

    ModuleDeclaration.prototype.checkSource = function() {
      if ((this.source != null) && this.source instanceof StringWithInterpolations) {
        return this.source.error('the name of the module to be imported from must be an uninterpolated string');
      }
    };

    ModuleDeclaration.prototype.checkScope = function(o, moduleDeclarationType) {
      if (o.indent.length !== 0) {
        return this.error(moduleDeclarationType + " statements must be at top-level scope");
      }
    };

    return ModuleDeclaration;

  })(Base);

  exports.ImportDeclaration = ImportDeclaration = (function(superClass1) {
    extend1(ImportDeclaration, superClass1);

    function ImportDeclaration() {
      return ImportDeclaration.__super__.constructor.apply(this, arguments);
    }

    ImportDeclaration.prototype.compileNode = function(o) {
      var ref3;
      this.checkScope(o, 'import');
      o.importedSymbols = [];
      let code = [];
      code.push(this.makeCode(this.tab + "import "));
      if (this.clause != null) {
        code.push.apply(code, this.clause.compileNode(o));
      }
      if (((ref3 = this.source) != null ? ref3.value : void 0) != null) {
        if (this.clause !== null) {
          code.push(this.makeCode(' from '));
        }
        code.push(this.makeCode(this.source.value));
      }
      code.push(this.makeCode(';'));
      return code;
    };

    return ImportDeclaration;

  })(ModuleDeclaration);

  exports.ImportClause = ImportClause = (function(superClass1) {
    extend1(ImportClause, superClass1);

    function ImportClause(defaultBinding, namedImports) {
      this.defaultBinding = defaultBinding;
      this.namedImports = namedImports;
    }

    ImportClause.prototype.children = ['defaultBinding', 'namedImports'];

    ImportClause.prototype.compileNode = function(o) {
      let code = [];
      if (this.defaultBinding != null) {
        code.push.apply(code, this.defaultBinding.compileNode(o));
        if (this.namedImports != null) {
          code.push(this.makeCode(', '));
        }
      }
      if (this.namedImports != null) {
        code.push.apply(code, this.namedImports.compileNode(o));
      }
      return code;
    };

    return ImportClause;

  })(Base);

  exports.ExportDeclaration = ExportDeclaration = (function(superClass1) {
    extend1(ExportDeclaration, superClass1);

    function ExportDeclaration() {
      return ExportDeclaration.__super__.constructor.apply(this, arguments);
    }

    ExportDeclaration.prototype.compileNode = function(o) {
      var ref3;
      this.checkScope(o, 'export');
      let code = [];
      code.push(this.makeCode(this.tab + "export "));
      if (this instanceof ExportDefaultDeclaration) {
        code.push(this.makeCode('default '));
      }
      if (!(this instanceof ExportDefaultDeclaration) && (this.clause instanceof Assign || this.clause instanceof Class)) {
        // Prevent exporting an anonymous class; all exported members must be named
        if (this.clause instanceof Class && !this.clause.variable) {
          this.clause.error('anonymous classes cannot be exported');
        }
        // When the ES2015 `class` keyword is supported, dont add a `var` here
        code.push(this.makeCode('var '));
        this.clause.moduleDeclaration = 'export';
      }
      // Prevent let-declaration for "export default"
      if (this instanceof ExportDefaultDeclaration && this.clause instanceof Assign) {
        this.clause.canDeclare = false;
      }
      if ((this.clause.body != null) && this.clause.body instanceof Block) {
        code = code.concat(this.clause.compileToFragments(o, LEVEL_TOP));
      } else {
        code = code.concat(this.clause.compileNode(o));
      }
      if (((ref3 = this.source) != null ? ref3.value : void 0) != null) {
        code.push(this.makeCode(" from " + this.source.value));
      }
      code.push(this.makeCode(';'));
      return code;
    };

    return ExportDeclaration;

  })(ModuleDeclaration);

  exports.ExportNamedDeclaration = ExportNamedDeclaration = (function(superClass1) {
    extend1(ExportNamedDeclaration, superClass1);

    function ExportNamedDeclaration() {
      return ExportNamedDeclaration.__super__.constructor.apply(this, arguments);
    }

    return ExportNamedDeclaration;

  })(ExportDeclaration);

  exports.ExportDefaultDeclaration = ExportDefaultDeclaration = (function(superClass1) {
    extend1(ExportDefaultDeclaration, superClass1);

    function ExportDefaultDeclaration() {
      return ExportDefaultDeclaration.__super__.constructor.apply(this, arguments);
    }

    return ExportDefaultDeclaration;

  })(ExportDeclaration);

  exports.ExportAllDeclaration = ExportAllDeclaration = (function(superClass1) {
    extend1(ExportAllDeclaration, superClass1);

    function ExportAllDeclaration() {
      return ExportAllDeclaration.__super__.constructor.apply(this, arguments);
    }

    return ExportAllDeclaration;

  })(ExportDeclaration);

  exports.ModuleSpecifierList = ModuleSpecifierList = (function(superClass1) {
    extend1(ModuleSpecifierList, superClass1);

    function ModuleSpecifierList(specifiers) {
      this.specifiers = specifiers;
    }

    ModuleSpecifierList.prototype.children = ['specifiers'];

    ModuleSpecifierList.prototype.compileNode = function(o) {
      var fragments, index, j, len1, specifier;
      let code = [];
      o.indent += TAB;
      let compiledList = (function() {
        var j, len1, ref3, results;
        ref3 = this.specifiers;
        results = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          specifier = ref3[j];
          results.push(specifier.compileToFragments(o, LEVEL_LIST));
        }
        return results;
      }).call(this);
      if (this.specifiers.length !== 0) {
        code.push(this.makeCode("{\n" + o.indent));
        for (index = j = 0, len1 = compiledList.length; j < len1; index = ++j) {
          fragments = compiledList[index];
          if (index) {
            code.push(this.makeCode(",\n" + o.indent));
          }
          code.push.apply(code, fragments);
        }
        code.push(this.makeCode("\n}"));
      } else {
        code.push(this.makeCode('{}'));
      }
      return code;
    };

    return ModuleSpecifierList;

  })(Base);

  exports.ImportSpecifierList = ImportSpecifierList = (function(superClass1) {
    extend1(ImportSpecifierList, superClass1);

    function ImportSpecifierList() {
      return ImportSpecifierList.__super__.constructor.apply(this, arguments);
    }

    return ImportSpecifierList;

  })(ModuleSpecifierList);

  exports.ExportSpecifierList = ExportSpecifierList = (function(superClass1) {
    extend1(ExportSpecifierList, superClass1);

    function ExportSpecifierList() {
      return ExportSpecifierList.__super__.constructor.apply(this, arguments);
    }

    return ExportSpecifierList;

  })(ModuleSpecifierList);

  exports.ModuleSpecifier = ModuleSpecifier = (function(superClass1) {
    extend1(ModuleSpecifier, superClass1);

    function ModuleSpecifier(original, alias, moduleDeclarationType1) {
      // The name of the variable entering the local scope
      this.original = original;
      this.alias = alias;
      this.moduleDeclarationType = moduleDeclarationType1;
      this.identifier = this.alias != null ? this.alias.value : this.original.value;
    }

    ModuleSpecifier.prototype.children = ['original', 'alias'];

    ModuleSpecifier.prototype.compileNode = function(o) {
      o.scope.find(this.identifier, this.moduleDeclarationType);
      let code = [];
      code.push(this.makeCode(this.original.value));
      if (this.alias != null) {
        code.push(this.makeCode(" as " + this.alias.value));
      }
      return code;
    };

    return ModuleSpecifier;

  })(Base);

  exports.ImportSpecifier = ImportSpecifier = (function(superClass1) {
    extend1(ImportSpecifier, superClass1);

    function ImportSpecifier(imported, local) {
      ImportSpecifier.__super__.constructor.call(this, imported, local, 'import');
    }

    ImportSpecifier.prototype.compileNode = function(o) {
      // Per the spec, symbols cant be imported multiple times
      // (e.g. `import { foo, foo } from 'lib'` is invalid)
      var ref3;
      if ((ref3 = this.identifier, indexOf.call(o.importedSymbols, ref3) >= 0) || o.scope.check(this.identifier)) {
        this.error("'" + this.identifier + "' has already been declared");
      } else {
        o.importedSymbols.push(this.identifier);
      }
      return ImportSpecifier.__super__.compileNode.call(this, o);
    };

    return ImportSpecifier;

  })(ModuleSpecifier);

  exports.ImportDefaultSpecifier = ImportDefaultSpecifier = (function(superClass1) {
    extend1(ImportDefaultSpecifier, superClass1);

    function ImportDefaultSpecifier() {
      return ImportDefaultSpecifier.__super__.constructor.apply(this, arguments);
    }

    return ImportDefaultSpecifier;

  })(ImportSpecifier);

  exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier = (function(superClass1) {
    extend1(ImportNamespaceSpecifier, superClass1);

    function ImportNamespaceSpecifier() {
      return ImportNamespaceSpecifier.__super__.constructor.apply(this, arguments);
    }

    return ImportNamespaceSpecifier;

  })(ImportSpecifier);

  exports.ExportSpecifier = ExportSpecifier = (function(superClass1) {
    extend1(ExportSpecifier, superClass1);

    function ExportSpecifier(local, exported) {
      ExportSpecifier.__super__.constructor.call(this, local, exported, 'export');
    }

    return ExportSpecifier;

  })(ModuleSpecifier);

  //### Assign
  // The **Assign** is used to assign a local variable to value, or to set the
  // property of an object -- including within object literals.
  exports.Assign = Assign = (function(superClass1) {
    extend1(Assign, superClass1);

    function Assign(variable1, value1, context, options) {
      this.variable = variable1;
      this.value = value1;
      this.context = context;
      if (options == null) {
        options = {};
      }
      this.param = options.param, this.subpattern = options.subpattern, this.operatorToken = options.operatorToken, this.moduleDeclaration = options.moduleDeclaration;
    }

    Assign.prototype.children = ['variable', 'value'];

    Assign.prototype.isStatement = function(o) {
      return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && (this.moduleDeclaration || indexOf.call(this.context, "?") >= 0);
    };

    Assign.prototype.checkAssignability = function(o, varBase) {
      if (Object.prototype.hasOwnProperty.call(o.scope.positions, varBase.value) && o.scope.variables[o.scope.positions[varBase.value]].type === 'import') {
        return varBase.error("'" + varBase.value + "' is read-only");
      }
    };

    Assign.prototype.assigns = function(name) {
      return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
    };

    Assign.prototype.unfoldSoak = function(o) {
      return unfoldSoak(o, this, 'variable');
    };

    // Compile an assignment, delegating to `compilePatternMatch` or
    // `compileSplice` if appropriate. Keep track of the name of the base object
    // we've been assigned to, for correct internal references. If the variable
    // has not been seen yet within the current scope, declare it.
    Assign.prototype.compileNode = function(o) {
      var comment, isValue, j, k, klass, kls, len1, method, name, properties, prototype, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      this.icedStatementAssertion();
      if (isValue = this.variable instanceof Value) {
        if (this.variable.isArray() || this.variable.isObject()) {
          return this.compilePatternMatch(o);
        }
        if (this.variable.isSplice()) {
          return this.compileSplice(o);
        }
        if ((ref3 = this.context) === '||=' || ref3 === '&&=' || ref3 === '?=') {
          return this.compileConditional(o);
        }
        if ((ref4 = this.context) === '**=' || ref4 === '//=' || ref4 === '%%=') {
          return this.compileSpecialMath(o);
        }
      }
      if (this.value instanceof Code) {
        // Also first pass of trying to create icedTraceName.
        if (this.value["static"]) {
          // Static method (class A: @func: ->)
          this.value.klass = this.variable.base;
          this.value.name = this.variable.properties[0];
          this.value.variable = this.variable;
          if ((klass = (ref5 = this.variable.base) != null ? ref5.value : void 0) && (method = (ref6 = this.variable.properties[0]) != null ? (ref7 = ref6.name) != null ? ref7.value : void 0 : void 0)) {
            this.value.icedTraceName = klass + "::@" + method;
          }
        } else if (((ref8 = this.variable.properties) != null ? ref8.length : void 0) >= 2) {
          // Normal class methods.
          ref9 = this.variable.properties, properties = 3 <= ref9.length ? slice.call(ref9, 0, j = ref9.length - 2) : (j = 0, []), prototype = ref9[j++], name = ref9[j++];
          if (((ref10 = prototype.name) != null ? ref10.value : void 0) === 'prototype') {
            this.value.klass = new Value(this.variable.base, properties);
            this.value.name = name;
            this.value.variable = this.variable;
            if ((klass = (ref11 = this.variable.base) != null ? ref11.value : void 0) && (method = (ref12 = name.name) != null ? ref12.value : void 0)) {
              this.value.icedTraceName = klass + "::" + method;
            }
          }
        } else if ((kls = this.value.icedPrivateOfCls)) {
          // Private function of a class (class A: func = ->)
          if ((klass = (ref13 = kls.base) != null ? ref13.value : void 0) && (method = (ref14 = this.variable.base) != null ? ref14.value : void 0)) {
            this.value.icedTraceName = klass + "::\#" + method;
          }
        } else if (this.variable.base instanceof IdentifierLiteral && !this.variable.properties.length) {
          // Simple common case of assignment to a variable
          this.value.icedTraceName = this.variable.base.value;
        }
      }
      let jsdocComment = null;
      if (o.comments) {
        let locData = (ref15 = this.locationData) != null ? ref15 : this.variable.locationData;
        ref16 = o.comments;
        for (k = 0, len1 = ref16.length; k < len1; k++) {
          comment = ref16[k];
          if (comment.jsdoc && comment.locationData.last_line === locData.first_line - 1) {
            comment.jsdocConsumed = true;
            jsdocComment = comment;
            //console.log @
            break;
          }
        }
      }
      let shouldDeclare = false;
      if (!this.context) {
        let varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable()) {
          this.variable.error("'" + (this.variable.compile(o)) + "' can't be assigned");
        }
        if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0)) {
          // `moduleDeclaration` can be `'import'` or `'export'`
          if (this.moduleDeclaration) {
            this.checkAssignability(o, varBase);
            o.scope.add(varBase.value, this.moduleDeclaration);
          } else if (this.param) {
            o.scope.add(varBase.value, 'var');
          } else {
            this.checkAssignability(o, varBase);
            let found = o.scope.find(varBase.value);
            if (!found && this.canDeclare && o.level === LEVEL_TOP) {
              o.scope.add(varBase.value, 'let');
              shouldDeclare = true;
            }
          }
        }
      }
      if (this.value instanceof Code && !this.value.icedTraceName) {
        // Save compiled variable name for icedTraceName if
        // wasn't obtained already.
        // This has to be ready before @value is compiled. But also
        // @value has to be compiled before @variable. So we compile
        // @variable twice, first time here, just to get the name.
        name = this.variable.compileToFragments(o, LEVEL_LIST);
        this.value.icedTraceName = fragmentsToText(name);
      }
      let val = this.value.compileToFragments(o, LEVEL_LIST);
      if (isValue && this.variable.base instanceof Obj) {
        this.variable.front = true;
      }
      let compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
      if (this.context === 'object') {
        if (ref17 = fragmentsToText(compiledName), indexOf.call(JS_FORBIDDEN, ref17) >= 0) {
          compiledName.unshift(this.makeCode('"'));
          compiledName.push(this.makeCode('"'));
        }
        return compiledName.concat(this.makeCode(": "), val);
      }
      let answer = compiledName.concat(this.makeCode(" " + (this.context || '=') + " "), val);
      if (shouldDeclare) {
        answer.unshift(this.makeCode("let "));
      }
      if (jsdocComment) {
        answer.unshift(this.makeCode("/**" + jsdocComment.text + " */\n" + o.indent));
      }
      //console.log answer.map((x) -> x.code)
      if (o.level <= LEVEL_LIST) {
        return answer;
      } else {
        return this.wrapInBraces(answer);
      }
    };

    // Brief implementation of recursive pattern matching, when assigning array or
    // object literals to a value. Peeks at their properties to assign inner names.
    Assign.prototype.compilePatternMatch = function(o) {
      var acc, defaultValue, i, idx, ivar, j, len1, message, name, obj, objects, olen, ref, ref3, ref4, ref5, ref6, rest, val, value;
      let top = o.level === LEVEL_TOP;
      value = this.value;
      objects = this.variable.base.objects;
      if (!(olen = objects.length)) {
        let code = value.compileToFragments(o);
        if (o.level >= LEVEL_OP) {
          return this.wrapInBraces(code);
        } else {
          return code;
        }
      }
      obj = objects[0];
      if (olen === 1 && obj instanceof Expansion) {
        obj.error('Destructuring assignment has no target');
      }
      let isObject = this.variable.isObject();
      if (top && olen === 1 && !(obj instanceof Splat)) {
        // Pick the property straight off the value when theres just one to pick
        // (no need to cache the value into a variable).
        defaultValue = null;
        if (obj instanceof Assign && obj.context === 'object') {
          // A regular object pattern-match.
          ref3 = obj, (ref4 = ref3.variable, idx = ref4.base), obj = ref3.value;
          if (obj instanceof Assign) {
            defaultValue = obj.value;
            obj = obj.variable;
          }
        } else {
          if (obj instanceof Assign) {
            defaultValue = obj.value;
            obj = obj.variable;
          }
          idx = isObject ?  /* A shorthand `{a, b, @c} = val` pattern-match. */ obj["this"] ? obj.properties[0].name : new PropertyName(obj.unwrap().value) :  /* A regular array pattern-match. */ new NumberLiteral(0);
        }
        acc = idx.unwrap() instanceof PropertyName;
        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));
        message = isUnassignable(obj.unwrap().value);
        if (message) {
          obj.error(message);
        }
        if (defaultValue) {
          value = new Op('?', value, defaultValue);
        }
        return new Assign(obj, value, null, {
          param: this.param
        }).compileToFragments(o, LEVEL_TOP);
      }
      let vvar = value.compileToFragments(o, LEVEL_LIST);
      let vvarText = fragmentsToText(vvar);
      let assigns = [];
      let expandedIdx = false;
      // Make vvar into a simple variable if it isn't already.
      if (!(value.unwrap() instanceof IdentifierLiteral) || this.variable.assigns(vvarText)) {
        assigns.push([this.makeCode((ref = o.scope.freeVariable('ref')) + " = ")].concat(slice.call(vvar)));
        vvar = [this.makeCode(ref)];
        vvarText = ref;
      }
      for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {
        obj = objects[i];
        idx = i;
        if (!expandedIdx && obj instanceof Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = olen + " <= " + vvarText + ".length ? " + (utility('slice', o)) + ".call(" + vvarText + ", " + i;
          if (rest = olen - i - 1) {
            ivar = o.scope.freeVariable('i', {
              single: true
            });
            val += ", " + ivar + " = " + vvarText + ".length - " + rest + ") : (" + ivar + " = " + i + ", [])";
          } else {
            val += ") : []";
          }
          val = new Literal(val);
          expandedIdx = ivar + "++";
        } else if (!expandedIdx && obj instanceof Expansion) {
          if (rest = olen - i - 1) {
            if (rest === 1) {
              expandedIdx = vvarText + ".length - 1";
            } else {
              ivar = o.scope.freeVariable('i', {
                single: true
              });
              val = new Literal(ivar + " = " + vvarText + ".length - " + rest);
              expandedIdx = ivar + "++";
              assigns.push(val.compileToFragments(o, LEVEL_LIST));
            }
          }
          continue;
        } else {
          if (obj instanceof Splat || obj instanceof Expansion) {
            obj.error("multiple splats/expansions are disallowed in an assignment");
          }
          defaultValue = null;
          if (obj instanceof Assign && obj.context === 'object') {
            // A regular object pattern-match.
            ref5 = obj, (ref6 = ref5.variable, idx = ref6.base), obj = ref5.value;
            if (obj instanceof Assign) {
              defaultValue = obj.value;
              obj = obj.variable;
            }
          } else {
            if (obj instanceof Assign) {
              defaultValue = obj.value;
              obj = obj.variable;
            }
            idx = isObject ?  /* A shorthand `{a, b, @c} = val` pattern-match. */ obj["this"] ? obj.properties[0].name : new PropertyName(obj.unwrap().value) :  /* A regular array pattern-match. */ new Literal(expandedIdx || idx);
          }
          name = obj.unwrap().value;
          acc = idx.unwrap() instanceof PropertyName;
          val = new Value(new Literal(vvarText), [new (acc ? Access : Index)(idx)]);
          if (defaultValue) {
            val = new Op('?', val, defaultValue);
          }
        }
        if (name != null) {
          message = isUnassignable(name);
          if (message) {
            obj.error(message);
          }
        }
        assigns.push(new Assign(obj, val, null, {
          param: this.param,
          subpattern: true
        }).compileToFragments(o, LEVEL_LIST));
      }
      if (!(top || this.subpattern)) {
        assigns.push(vvar);
      }
      let fragments = this.joinFragmentArrays(assigns, ', ');
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    // When compiling a conditional assignment, take care to ensure that the
    // operands are only evaluated once, even though we have to reference them
    // more than once.
    Assign.prototype.compileConditional = function(o) {
      var left, ref3, right;
      ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
      // Disallow conditional assignment of undefined variables.
      if (!left.properties.length && left.base instanceof Literal && !(left.base instanceof ThisLiteral) && !o.scope.check(left.base.value)) {
        this.variable.error("the variable \"" + left.base.value + "\" can't be assigned with " + this.context + " because it has not been declared before");
      }
      if (indexOf.call(this.context, "?") >= 0) {
        o.isExistentialEquals = true;
        return new If(new Existence(left), right, {
          type: 'if'
        }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
      } else {
        let fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
        if (o.level <= LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInBraces(fragments);
        }
      }
    };

    // Convert special math assignment operators like `a **= b` to the equivalent
    // extended form `a = a ** b` and then compiles that.
    Assign.prototype.compileSpecialMath = function(o) {
      var left, ref3, right;
      ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
      return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
    };

    // Compile the assignment from an array splice literal, using JavaScript's
    // `Array#splice` method.
    Assign.prototype.compileSplice = function(o) {
      var exclusive, from, fromDecl, fromRef, ref3, ref4, ref5, to, valDef, valRef;
      ref3 = this.variable.properties.pop().range, from = ref3.from, to = ref3.to, exclusive = ref3.exclusive;
      let name = this.variable.compile(o);
      if (from) {
        ref4 = this.cacheToCodeFragments(from.cache(o, LEVEL_OP)), fromDecl = ref4[0], fromRef = ref4[1];
      } else {
        fromDecl = fromRef = '0';
      }
      if (to) {
        if ((from != null ? from.isNumber() : void 0) && to.isNumber()) {
          to = to.compile(o) - fromRef;
          if (!exclusive) {
            to += 1;
          }
        } else {
          to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
          if (!exclusive) {
            to += ' + 1';
          }
        }
      } else {
        to = "9e9";
      }
      ref5 = this.value.cache(o, LEVEL_LIST), valDef = ref5[0], valRef = ref5[1];
      let answer = [].concat(this.makeCode("[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat("), valDef, this.makeCode(")), "), valRef);
      if (o.level > LEVEL_TOP) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Assign.prototype.variableDeclarationWalk = function(opts) {
      // Deal with checking variable first.
      (function(_this) {
        return (function() {
          if (_this.context || _this.moduleDeclaration || _this.param) {
            return;
          }
          let varBase = _this.variable.unwrapAll();
          if (typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0) {
            return;
          }
          let v = varBase.value;
          if (v) {
            // If not already declared by outer scope
            if (!opts.scope.check(v)) {
              return opts.checkVar(v, opts, {
                assign: _this
              });
            }
          }
        });
      })(this)();
      // Now run the declaration walk on value.
      return this.value.variableDeclarationWalk(opts);
    };

    return Assign;

  })(Base);

  //### Code
  // A function definition. This is the only node that creates a new Scope.
  // When for the purposes of walking the contents of a function body, the Code
  // has no *children* -- they're within the inner scope.
  exports.Code = Code = (function(superClass1) {
    extend1(Code, superClass1);

    function Code() {
      var body, params, tags;
      params = arguments[0], body = arguments[1], tags = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.params = params || [];
      this.body = body || new Block;
      this.icedgen = indexOf.call(tags, 'icedgen') >= 0;
      this.bound = indexOf.call(tags, 'boundfunc') >= 0;
      this.isGenerator = !!this.body.contains(function(node) {
        return (node instanceof Op && node.isYield()) || node instanceof YieldReturn;
      });
    }

    Code.prototype.children = ['params', 'body'];

    Code.prototype.isStatement = function() {
      return !!this.ctor;
    };

    Code.prototype.jumps = NO;

    Code.prototype.makeScope = function(parentScope) {
      return new Scope(parentScope, this.body, this);
    };

    // Compilation creates a new scope unless explicitly asked to share with the
    // outer scope. Handles splat parameters in the parameter list by peeking at
    // the JavaScript `arguments` object. If the function is bound with the `=>`
    // arrow, generates a wrapper that saves the current value of `this` through
    // a closure.
    Code.prototype.compileNode = function(o) {
      var i, j, k, len1, len2, len3, len4, len5, len6, m, p, param, q, r, ref, ref3, ref4, ref5, ref6, ref7, ref8, splats, t, val;
      if (this.foundAutocb) {
        this.error('autocb is deprecated.');
      }
      if (this.bound && ((ref3 = o.scope.method) != null ? ref3.bound : void 0)) {
        this.context = o.scope.method.context;
      }
      // Handle iced functions early
      if (this.icedFlag) {
        this.icedTransform();
      }
      // Handle bound functions early.
      if (this.bound && !this.context) {
        this.context = '_this';
        let wrapper = new Code([new Param(new IdentifierLiteral(this.context))], new Block([this]));
        let boundfunc = new Call(wrapper, [new ThisLiteral]);
        boundfunc.updateLocationDataIfMissing(this.locationData);
        return boundfunc.compileNode(o);
      }
      o.scope = del(o, 'classScope') || this.makeScope(o.scope);
      o.scope.shared = del(o, 'sharedScope') || this.icedgen;
      o.scope.icedgen = this.icedgen;
      if (this.icedUseArguments) {
        o.scope.icedUseArguments = this.icedUseArguments;
      }
      o.indent += TAB;
      delete o.bare;
      delete o.isExistentialEquals;
      let params = [];
      let exprs = [];
      //console.log 'dec walk for', o.scope.method?.icedTraceName ? '?'
      this.body.doVariableDeclarationWalk(o.scope);
      ref4 = this.params;
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        param = ref4[j];
        if (!(param instanceof Expansion)) {
          o.scope.parameter(param.asReference(o));
        }
      }
      ref5 = this.params;
      for (k = 0, len2 = ref5.length; k < len2; k++) {
        param = ref5[k];
        if (!(param.splat || param instanceof Expansion)) {
          continue;
        }
        ref6 = this.params;
        for (m = 0, len3 = ref6.length; m < len3; m++) {
          p = ref6[m];
          if (!(p instanceof Expansion) && p.name.value) {
            o.scope.add(p.name.value, 'var', true);
          }
        }
        splats = new Assign(new Value(new Arr((function() {
          var len4, q, ref7, results;
          ref7 = this.params;
          results = [];
          for (q = 0, len4 = ref7.length; q < len4; q++) {
            p = ref7[q];
            results.push(p.asReference(o));
          }
          return results;
        }).call(this))), new Value(new IdentifierLiteral('arguments')));
        break;
      }
      ref7 = this.params;
      for (q = 0, len4 = ref7.length; q < len4; q++) {
        param = ref7[q];
        if (param.isComplex()) {
          val = ref = param.asReference(o);
          if (param.value) {
            val = new Op('?', ref, param.value);
          }
          exprs.push(new Assign(new Value(param.name), val, '=', {
            param: true
          }));
        } else {
          ref = param;
          if (param.value) {
            let lit = new Literal(ref.name.value + ' == null');
            val = new Assign(new Value(param.name), param.value, '=');
            exprs.push(new If(lit, val));
          }
        }
        if (!splats) {
          params.push(ref);
        }
      }
      let wasEmpty = this.body.isEmpty();
      if (splats) {
        exprs.unshift(splats);
      }
      if (exprs.length) {
        (ref8 = this.body.expressions).unshift.apply(ref8, exprs);
      }
      for (i = r = 0, len5 = params.length; r < len5; i = ++r) {
        p = params[i];
        params[i] = p.compileToFragments(o);
        o.scope.parameter(fragmentsToText(params[i]));
      }
      let uniqs = [];
      this.eachParamName(function(name, node) {
        if (indexOf.call(uniqs, name) >= 0) {
          node.error("multiple parameters named " + name);
        }
        return uniqs.push(name);
      });
      if (!(wasEmpty || this.noReturn)) {
        this.body.makeReturn();
      }
      if (this.icedSaveArguments) {
        let arg_var = o.scope.freeVariable('_arguments');
        o.scope.icedArgumentsVar = arg_var;
        this.body.expressions.unshift(new Assign(new IdentifierLiteral(arg_var), new Literal('arguments')));
      }
      let code = 'function';
      if (this.isGenerator) {
        code += '*';
      }
      if (this.ctor) {
        code += ' ' + this.name;
      }
      code += '(';
      let answer = [this.makeCode(code)];
      for (i = t = 0, len6 = params.length; t < len6; i = ++t) {
        p = params[i];
        if (i) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, p);
      }
      answer.push(this.makeCode(') {'));
      if (!this.body.isEmpty()) {
        answer = answer.concat(this.makeCode("\n"), this.body.compileWithDeclarations(o), this.makeCode("\n" + this.tab));
      }
      answer.push(this.makeCode('}'));
      if (this.ctor) {
        return [this.makeCode(this.tab)].concat(slice.call(answer));
      }
      if (this.front || (o.level >= LEVEL_ACCESS)) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Code.prototype.eachParamName = function(iterator) {
      var j, len1, param, ref3, results;
      ref3 = this.params;
      results = [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        param = ref3[j];
        results.push(param.eachName(iterator));
      }
      return results;
    };

    // Short-circuit `traverseChildren` method to prevent it from crossing scope boundaries
    // unless `crossScope` is `true`.
    Code.prototype.traverseChildren = function(crossScope, func) {
      if (crossScope) {
        return Code.__super__.traverseChildren.call(this, crossScope, func);
      }
    };

    //----------
    // IcedCoffeeScript Additions
    Code.prototype.icedTransform = function() {
      // Error condition of generators + await, which don't mix
      if (this.isGenerator) {
        this.error("Methods with `await` cannot be generators");
      }
      // Don't do the same operation the next time through
      this.icedFlag = false;
      this.icedPassedDeferral = new Value(new IdentifierLiteral(iced["const"].passed_deferral));
      this.icedIterator = new Value(new IdentifierLiteral(iced["const"].iterator));
      let body = [];
      // var __iced_passed_deferral = iced.findDeferral(arguments)
      let f = new Value(new IdentifierLiteral(iced["const"].ns));
      f.add(new Access(new PropertyName(iced["const"].findDeferral)));
      let rhs = new Call(f, [new Value(new IdentifierLiteral('arguments'))]);
      body.push(new Assign(this.icedPassedDeferral, rhs, null, {
        param: true
      }));
      // var __it = (function*() { [ @body ]} )();
      let tags = ['icedgen'];
      // Only bind the inner generator function if there are any
      // references to `this` in the body.
      if (this.icedFoundThis) {
        tags.push('boundfunc');
      }
      let code = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Code, [[], new Block([this.body])].concat(slice.call(tags)), function(){});
      code.isGenerator = true;
      if (this.icedFoundArguments) {
        this.icedSaveArguments = true;
        code.icedUseArguments = true;
      }
      rhs = new Call(code, []);
      body.push(new Assign(this.icedIterator, rhs, null, {
        param: true
      }));
      // __it.next();
      let nxt = this.icedIterator.copy();
      nxt.add(new Access(new PropertyName("next")));
      let call = new Call(nxt, []);
      body.push(call);
      // return null;
      // we don't want to return result of __it.next() which is typically
      // something like `{ value: undefined, done: false }`.
      body.push(new NullLiteral);
      return this.body = Block.wrap(body);
    };

    Code.prototype.icedWalkAst = function(o) {
      // Replace context for new function scope.
      var j, len1, param, ref3;
      let o_new = {
        func: this
      };
      Code.__super__.icedWalkAst.call(this, o_new);
      o.awaitInFile || (o.awaitInFile = o_new.awaitInFile);
      o.deferInFile || (o.deferInFile = o_new.deferInFile);
      o.foundThis || (o.foundThis = this.bound);
      this.icedFlag = o_new.awaitInFunc;
      this.icedFoundArguments = o.foundArguments || o_new.foundArguments;
      this.icedFoundThis = this.bound || o_new.foundThis;
      ref3 = this.params;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        param = ref3[j];
        if (param.name instanceof Literal && param.name.value === iced["const"].autocb) {
          this.foundAutocb = true;
          break;
        }
      }
      return this;
    };

    Code.prototype.variableDeclarationWalk = function(opts) {
      // Do special kind of walk when we are crossing scope boundaries.
      // Only do kills on reads.
      return Code.__super__.variableDeclarationWalk.call(this, Object.assign({
        crossedScope: true
      }, opts));
    };

    return Code;

  })(Base);

  // /IcedCoffeeScript Additions
  //----------
  //### Param
  // A parameter in a function definition. Beyond a typical JavaScript parameter,
  // these parameters can also attach themselves to the context of the function,
  // as well as be a splat, gathering up a group of parameters into an array.
  exports.Param = Param = (function(superClass1) {
    extend1(Param, superClass1);

    function Param(name1, value1, splat1) {
      this.name = name1;
      this.value = value1;
      this.splat = splat1;
      let message = isUnassignable(this.name.unwrapAll().value);
      if (message) {
        this.name.error(message);
      }
      if (this.name instanceof Obj && this.name.generated) {
        let token = this.name.objects[0].operatorToken;
        token.error("unexpected " + token.value);
      }
    }

    Param.prototype.children = ['name', 'value'];

    Param.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o, LEVEL_LIST);
    };

    Param.prototype.asReference = function(o) {
      if (this.reference) {
        return this.reference;
      }
      let node = this.name;
      if (node["this"]) {
        let name = node.properties[0].name.value;
        if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
          name = "_" + name;
        }
        node = new IdentifierLiteral(o.scope.freeVariable(name));
      } else if (node.isComplex()) {
        node = new IdentifierLiteral(o.scope.freeVariable('arg'));
      }
      node = new Value(node);
      if (this.splat) {
        node = new Splat(node);
      }
      node.updateLocationDataIfMissing(this.locationData);
      return this.reference = node;
    };

    Param.prototype.isComplex = function() {
      return this.name.isComplex();
    };

    // Iterates the name or names of a `Param`.
    // In a sense, a destructured parameter represents multiple JS parameters. This
    // method allows to iterate them all.
    // The `iterator` function will be called as `iterator(name, node)` where
    // `name` is the name of the parameter and `node` is the AST node corresponding
    // to that name.
    Param.prototype.eachName = function(iterator, name) {
      var j, len1, obj, ref3, ref4;
      if (name == null) {
        name = this.name;
      }
      let atParam = function(obj) {
        return iterator("@" + obj.properties[0].name.value, obj);
      };
      // * simple literals `foo`
      if (name instanceof Literal) {
        return iterator(name.value, name);
      }
      // * at-params `@foo`
      if (name instanceof Value) {
        return atParam(name);
      }
      ref4 = (ref3 = name.objects) != null ? ref3 : [];
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        obj = ref4[j];
        // * destructured parameter with default value
        if (obj instanceof Assign && (obj.context == null)) {
          obj = obj.variable;
        }
        // * assignments within destructured parameters `{foo:bar}`
        if (obj instanceof Assign) {
          // ... possibly with a default value
          if (obj.value instanceof Assign) {
            obj = obj.value;
          }
          this.eachName(iterator, obj.value.unwrap());
        } else  /* * splats within destructured parameters `[xs...]` */ if (obj instanceof Splat) {
          let node = obj.name.unwrap();
          iterator(node.value, node);
        } else if (obj instanceof Value) {
          // * destructured parameters within destructured parameters `[{a}]`
          if (obj.isArray() || obj.isObject()) {
            this.eachName(iterator, obj.base);
          } else  /* * at-params within destructured parameters `{@foo}` */ if (obj["this"]) {
            atParam(obj);
          } else {
            // * simple destructured parameters {foo}
            iterator(obj.base.value, obj.base);
          }
        } else if (!(obj instanceof Expansion)) {
          obj.error("illegal parameter " + (obj.compile()));
        }
      }
    };

    return Param;

  })(Base);

  //### Splat
  // A splat, either as a parameter to a function, an argument to a call,
  // or as part of a destructuring assignment.
  exports.Splat = Splat = (function(superClass1) {
    extend1(Splat, superClass1);

    Splat.prototype.children = ['name'];

    Splat.prototype.isAssignable = YES;

    function Splat(name) {
      this.name = name.compile ? name : new Literal(name);
    }

    Splat.prototype.assigns = function(name) {
      return this.name.assigns(name);
    };

    Splat.prototype.compileNode = function(o) {
      return this.name.compileToFragments(o);
    };

    Splat.prototype.unwrap = function() {
      return this.name;
    };

    // Utility function that converts an arbitrary number of elements, mixed with
    // splats, to a proper array.
    Splat.compileSplattedArray = function(o, list, apply) {
      var concatPart, i, j, last, len1, node;
      let index = -1;
      while ((node = list[++index]) && !(node instanceof Splat)) {
        continue;
      }
      if (index >= list.length) {
        return [];
      }
      if (list.length === 1) {
        node = list[0];
        let fragments = node.compileToFragments(o, LEVEL_LIST);
        if (apply) {
          return fragments;
        }
        return [].concat(node.makeCode((utility('slice', o)) + ".call("), fragments, node.makeCode(")"));
      }
      let args = list.slice(index);
      for (i = j = 0, len1 = args.length; j < len1; i = ++j) {
        node = args[i];
        let compiledNode = node.compileToFragments(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? [].concat(node.makeCode((utility('slice', o)) + ".call("), compiledNode, node.makeCode(")")) : [].concat(node.makeCode("["), compiledNode, node.makeCode("]"));
      }
      if (index === 0) {
        node = list[0];
        concatPart = node.joinFragmentArrays(args.slice(1), ', ');
        return args[0].concat(node.makeCode(".concat("), concatPart, node.makeCode(")"));
      }
      let base = (function() {
        var k, len2, ref3, results;
        ref3 = list.slice(0, index);
        results = [];
        for (k = 0, len2 = ref3.length; k < len2; k++) {
          node = ref3[k];
          results.push(node.compileToFragments(o, LEVEL_LIST));
        }
        return results;
      })();
      base = list[0].joinFragmentArrays(base, ', ');
      concatPart = list[index].joinFragmentArrays(args, ', ');
      last = list[list.length - 1];
      return [].concat(list[0].makeCode("["), base, list[index].makeCode("].concat("), concatPart, last.makeCode(")"));
    };

    Splat.prototype.icedToSlot = function(i) {
      return new Slot(i, new Value(this.name), null, true);
    };

    return Splat;

  })(Base);

  //### Expansion
  // Used to skip values inside an array destructuring (pattern matching) or
  // parameter list.
  exports.Expansion = Expansion = (function(superClass1) {
    extend1(Expansion, superClass1);

    function Expansion() {
      return Expansion.__super__.constructor.apply(this, arguments);
    }

    Expansion.prototype.isComplex = NO;

    Expansion.prototype.compileNode = function(o) {
      return this.error('Expansion must be used inside a destructuring assignment or parameter list');
    };

    Expansion.prototype.asReference = function(o) {
      return this;
    };

    Expansion.prototype.eachName = function(iterator) {};

    return Expansion;

  })(Base);

  //### While
  // A while loop, the only sort of low-level loop exposed by CoffeeScript. From
  // it, all other loops can be manufactured. Useful in cases where you need more
  // flexibility or more speed than a comprehension can provide.
  exports.While = While = (function(superClass1) {
    extend1(While, superClass1);

    function While(condition, options) {
      this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
      this.guard = options != null ? options.guard : void 0;
    }

    While.prototype.children = ['condition', 'guard', 'body'];

    While.prototype.isStatement = YES;

    While.prototype.makeReturn = function(res) {
      if (res) {
        return While.__super__.makeReturn.apply(this, arguments);
      } else {
        this.returns = !this.jumps({
          loop: true
        });
        return this;
      }
    };

    While.prototype.addBody = function(body1) {
      this.body = body1;
      return this;
    };

    While.prototype.jumps = function() {
      var expressions, j, jumpNode, len1, node;
      expressions = this.body.expressions;
      if (!expressions.length) {
        return false;
      }
      for (j = 0, len1 = expressions.length; j < len1; j++) {
        node = expressions[j];
        if (jumpNode = node.jumps({
          loop: true
        })) {
          return jumpNode;
        }
      }
      return false;
    };

    // The main difference from a JavaScript *while* is that the CoffeeScript
    // *while* can be used as a part of a larger expression -- while loops may
    // return an array containing the computed result of each iteration.
    While.prototype.compileNode = function(o) {
      var body, rvar;
      this.condition.icedStatementAssertion();
      o.indent += TAB;
      let set = '';
      body = this.body;
      if (body.isEmpty()) {
        body = this.makeCode('');
      } else {
        if (this.returns) {
          body.makeReturn(rvar = o.scope.freeVariable('results'));
          set = "" + this.tab + rvar + " = [];\n";
        }
        if (this.guard) {
          if (body.expressions.length > 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new StatementLiteral("continue")));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab));
      }
      let answer = [].concat(this.makeCode(set + this.tab + "while ("), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
      if (this.returns) {
        answer.push(this.makeCode("\n" + this.tab + "return " + rvar + ";"));
      }
      return answer;
    };

    return While;

  })(Base);

  //### Op
  // Simple Arithmetic and logical operations. Performs some conversion from
  // CoffeeScript operations into their JavaScript equivalents.
  exports.Op = Op = (function(superClass1) {
    extend1(Op, superClass1);

    function Op(op, first, second, flip) {
      if (op === 'in') {
        return new In(first, second);
      }
      if (op === 'do') {
        return this.generateDo(first);
      }
      if (op === 'new') {
        if (first instanceof Call && !first["do"] && !first.isNew) {
          return first.newInstance();
        }
        if (first instanceof Code && first.bound || first["do"]) {
          first = new Parens(first);
        }
      }
      this.operator = CONVERSIONS[op] || op;
      this.first = first;
      this.second = second;
      this.flip = !!flip;
      return this;
    }

    // The map of conversions from CoffeeScript to JavaScript symbols.
    let CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
    };

    // The map of invertible operators.
    let INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };

    Op.prototype.children = ['first', 'second'];

    Op.prototype.isNumber = function() {
      var ref3;
      return this.isUnary() && ((ref3 = this.operator) === '+' || ref3 === '-') && this.first instanceof Value && this.first.isNumber();
    };

    Op.prototype.isYield = function() {
      var ref3;
      return (ref3 = this.operator) === 'yield' || ref3 === 'yield*';
    };

    Op.prototype.isUnary = function() {
      return !this.second;
    };

    Op.prototype.isComplex = function() {
      return !this.isNumber();
    };

    // Am I capable of
    // [Python-style comparison chaining](https://docs.python.org/3/reference/expressions.html#not-in)?
    Op.prototype.isChainable = function() {
      var ref3;
      return (ref3 = this.operator) === '<' || ref3 === '>' || ref3 === '>=' || ref3 === '<=' || ref3 === '===' || ref3 === '!==';
    };

    Op.prototype.invert = function() {
      var fst, op, ref3;
      if (this.isChainable() && this.first.isChainable()) {
        let allInvertable = true;
        let curr = this;
        while (curr && curr.operator) {
          allInvertable && (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
        }
        if (!allInvertable) {
          return new Parens(this).invert();
        }
        curr = this;
        while (curr && curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        return this;
      } else if (op = INVERSIONS[this.operator]) {
        this.operator = op;
        if (this.first.unwrap() instanceof Op) {
          this.first.invert();
        }
        return this;
      } else if (this.second) {
        return new Parens(this).invert();
      } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((ref3 = fst.operator) === '!' || ref3 === 'in' || ref3 === 'instanceof')) {
        return fst;
      } else {
        return new Op('!', this);
      }
    };

    Op.prototype.unfoldSoak = function(o) {
      var ref3;
      return ((ref3 = this.operator) === '++' || ref3 === '--' || ref3 === 'delete') && unfoldSoak(o, this, 'first');
    };

    Op.prototype.generateDo = function(exp) {
      var j, len1, param, ref, ref3;
      let passedParams = [];
      let func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
      ref3 = func.params || [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        param = ref3[j];
        if (param.value) {
          passedParams.push(param.value);
          delete param.value;
        } else {
          passedParams.push(param);
        }
      }
      let call = new Call(exp, passedParams);
      call["do"] = true;
      return call;
    };

    Op.prototype.compileNode = function(o) {
      var ref3;
      let isChain = this.isChainable() && this.first.isChainable();
      // In chains, there's no need to wrap bare obj literals in parens,
      // as the chained expression is wrapped.
      if (!isChain) {
        this.first.front = this.front;
      }
      if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {
        this.error('delete operand may not be argument or var');
      }
      if ((ref3 = this.operator) === '--' || ref3 === '++') {
        let message = isUnassignable(this.first.unwrapAll().value);
        if (message) {
          this.first.error(message);
        }
      }
      if (this.isYield()) {
        return this.compileYield(o);
      }
      if (this.isUnary()) {
        return this.compileUnary(o);
      }
      if (isChain) {
        return this.compileChain(o);
      }
      switch (this.operator) {
        case '?':
          return this.compileExistence(o);
        case '**':
          return this.compilePower(o);
        case '//':
          return this.compileFloorDivision(o);
        case '%%':
          return this.compileModulo(o);
        default:
          let lhs = this.first.compileToFragments(o, LEVEL_OP);
          let rhs = this.second.compileToFragments(o, LEVEL_OP);
          let answer = [].concat(lhs, this.makeCode(" " + this.operator + " "), rhs);
          if (o.level <= LEVEL_OP) {
            return answer;
          } else {
            return this.wrapInBraces(answer);
          }
      }
    };

    // Mimic Python's chained comparisons when multiple comparison operators are
    // used sequentially. For example:
    //
    //     bin/coffee -e 'console.log 50 < 65 > 10'
    //     true
    Op.prototype.compileChain = function(o) {
      var ref3, shared;
      ref3 = this.first.second.cache(o), this.first.second = ref3[0], shared = ref3[1];
      let fst = this.first.compileToFragments(o, LEVEL_OP);
      let fragments = fst.concat(this.makeCode(" " + (this.invert ? '&&' : '||') + " "), shared.compileToFragments(o), this.makeCode(" " + this.operator + " "), this.second.compileToFragments(o, LEVEL_OP));
      return this.wrapInBraces(fragments);
    };

    // Keep reference to the left expression, unless this an existential assignment
    Op.prototype.compileExistence = function(o) {
      var fst, ref;
      if (this.first.isComplex()) {
        ref = new IdentifierLiteral(o.scope.freeVariable('ref'));
        fst = new Parens(new Assign(ref, this.first));
      } else {
        fst = this.first;
        ref = fst;
      }
      return new If(new Existence(fst), ref, {
        type: 'if'
      }).addElse(this.second).compileToFragments(o);
    };

    // Compile a unary **Op**.
    Op.prototype.compileUnary = function(o) {
      let parts = [];
      let op = this.operator;
      parts.push([this.makeCode(op)]);
      if (op === '!' && this.first instanceof Existence) {
        this.first.negated = !this.first.negated;
        return this.first.compileToFragments(o);
      }
      if (o.level >= LEVEL_ACCESS) {
        return (new Parens(this)).compileToFragments(o);
      }
      let plusMinus = op === '+' || op === '-';
      if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) {
        parts.push([this.makeCode(' ')]);
      }
      if ((plusMinus && this.first instanceof Op) || (op === 'new' && this.first.isStatement(o))) {
        this.first = new Parens(this.first);
      }
      parts.push(this.first.compileToFragments(o, LEVEL_OP));
      if (this.flip) {
        parts.reverse();
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compileYield = function(o) {
      var ref3;
      let parts = [];
      let op = this.operator;
      if (o.scope.parent == null) {
        this.error('yield can only occur inside functions');
      }
      if (indexOf.call(Object.keys(this.first), 'expression') >= 0 && !(this.first instanceof Throw)) {
        if (this.first.expression != null) {
          parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
        }
      } else {
        if (o.level >= LEVEL_PAREN) {
          parts.push([this.makeCode("(")]);
        }
        parts.push([this.makeCode(op)]);
        if (((ref3 = this.first.base) != null ? ref3.value : void 0) !== '') {
          parts.push([this.makeCode(" ")]);
        }
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        if (o.level >= LEVEL_PAREN) {
          parts.push([this.makeCode(")")]);
        }
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compilePower = function(o) {
      // Make a Math.pow call
      let pow = new Value(new IdentifierLiteral('Math'), [new Access(new PropertyName('pow'))]);
      return new Call(pow, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.compileFloorDivision = function(o) {
      let floor = new Value(new IdentifierLiteral('Math'), [new Access(new PropertyName('floor'))]);
      let second = this.second.isComplex() ? new Parens(this.second) : this.second;
      let div = new Op('/', this.first, second);
      return new Call(floor, [div]).compileToFragments(o);
    };

    Op.prototype.compileModulo = function(o) {
      let mod = new Value(new Literal(utility('modulo', o)));
      return new Call(mod, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.toString = function(idt) {
      return Op.__super__.toString.call(this, idt, this.constructor.name + ' ' + this.operator);
    };

    return Op;

  })(Base);

  //### In
  exports.In = In = (function(superClass1) {
    extend1(In, superClass1);

    function In(object, array) {
      this.object = object;
      this.array = array;
    }

    In.prototype.children = ['object', 'array'];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = function(o) {
      var hasSplat, j, len1, obj, ref3;
      if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
        ref3 = this.array.base.objects;
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          obj = ref3[j];
          if (!(obj instanceof Splat)) {
            continue;
          }
          hasSplat = true;
          break;
        }
        // `compileOrTest` only if we have an array literal with no splats
        if (!hasSplat) {
          return this.compileOrTest(o);
        }
      }
      return this.compileLoopTest(o);
    };

    In.prototype.compileOrTest = function(o) {
      var cmp, cnj, i, item, j, len1, ref, ref3, ref4, ref5, sub;
      ref3 = this.object.cache(o, LEVEL_OP), sub = ref3[0], ref = ref3[1];
      ref4 = this.negated ? [' !== ', ' && '] : [' === ', ' || '], cmp = ref4[0], cnj = ref4[1];
      let tests = [];
      ref5 = this.array.base.objects;
      for (i = j = 0, len1 = ref5.length; j < len1; i = ++j) {
        item = ref5[i];
        if (i) {
          tests.push(this.makeCode(cnj));
        }
        tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
      }
      if (o.level < LEVEL_OP) {
        return tests;
      } else {
        return this.wrapInBraces(tests);
      }
    };

    In.prototype.compileLoopTest = function(o) {
      var ref, ref3, sub;
      ref3 = this.object.cache(o, LEVEL_LIST), sub = ref3[0], ref = ref3[1];
      let fragments = [].concat(this.makeCode(utility('indexOf', o) + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
      if (fragmentsToText(sub) === fragmentsToText(ref)) {
        return fragments;
      }
      fragments = sub.concat(this.makeCode(', '), fragments);
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    In.prototype.toString = function(idt) {
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? '!' : ''));
    };

    return In;

  })(Base);

  //### Try
  // A classic *try/catch/finally* block.
  exports.Try = Try = (function(superClass1) {
    extend1(Try, superClass1);

    function Try(attempt, errorVariable, recovery, ensure) {
      this.attempt = attempt;
      this.errorVariable = errorVariable;
      this.recovery = recovery;
      this.ensure = ensure;
    }

    Try.prototype.children = ['attempt', 'recovery', 'ensure'];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = function(o) {
      var ref3;
      return this.attempt.jumps(o) || ((ref3 = this.recovery) != null ? ref3.jumps(o) : void 0);
    };

    Try.prototype.makeReturn = function(res) {
      if (this.attempt) {
        this.attempt = this.attempt.makeReturn(res);
      }
      if (this.recovery) {
        this.recovery = this.recovery.makeReturn(res);
      }
      return this;
    };

    // Compilation is more or less as you would expect -- the *finally* clause
    // is optional, the *catch* is not.
    Try.prototype.compileNode = function(o) {
      var generatedErrorVariableName, message, placeholder;
      o.indent += TAB;
      let tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
      let catchPart = this.recovery ? (generatedErrorVariableName = o.scope.freeVariable('error', {
        reserve: false
      }), placeholder = new IdentifierLiteral(generatedErrorVariableName), this.errorVariable ? (message = isUnassignable(this.errorVariable.unwrapAll().value), message ? this.errorVariable.error(message) : void 0, this.recovery.unshift(new Assign(this.errorVariable, placeholder))) : void 0, [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}"))) : !(this.ensure || this.recovery) ? (generatedErrorVariableName = o.scope.freeVariable('error', {
        reserve: false
      }), [this.makeCode(" catch (" + generatedErrorVariableName + ") {}")]) : [];
      let ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}")) : [];
      return [].concat(this.makeCode(this.tab + "try {\n"), tryPart, this.makeCode("\n" + this.tab + "}"), catchPart, ensurePart);
    };

    return Try;

  })(Base);

  //### Throw
  // Simple node to throw an exception.
  exports.Throw = Throw = (function(superClass1) {
    extend1(Throw, superClass1);

    function Throw(expression) {
      this.expression = expression;
    }

    Throw.prototype.children = ['expression'];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    // A **Throw** is already a return, of sorts...
    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = function(o) {
      return [].concat(this.makeCode(this.tab + "throw "), this.expression.compileToFragments(o), this.makeCode(";"));
    };

    return Throw;

  })(Base);

  //### Existence
  // Checks a variable for existence -- not *null* and not *undefined*. This is
  // similar to `.nil?` in Ruby, and avoids having to consult a JavaScript truth
  // table.
  exports.Existence = Existence = (function(superClass1) {
    extend1(Existence, superClass1);

    function Existence(expression) {
      this.expression = expression;
    }

    Existence.prototype.children = ['expression'];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = function(o) {
      var cmp, cnj, ref3;
      this.expression.front = this.front;
      let code = this.expression.compile(o, LEVEL_OP);
      if (this.expression.unwrap() instanceof IdentifierLiteral && !o.scope.check(code)) {
        ref3 = this.negated ? ['===', '||'] : ['!==', '&&'], cmp = ref3[0], cnj = ref3[1];
        code = "typeof " + code + " " + cmp + " \"undefined\" " + cnj + " " + code + " " + cmp + " null";
      } else {
        // do not use strict equality here; it will break existing code
        code = code + " " + (this.negated ? '==' : '!=') + " null";
      }
      return [this.makeCode(o.level <= LEVEL_COND ? code : "(" + code + ")")];
    };

    return Existence;

  })(Base);

  //### Parens
  // An extra set of parentheses, specified explicitly in the source. At one time
  // we tried to clean up the results by detecting and removing redundant
  // parentheses, but no longer -- you can put in as many as you please.
  //
  // Parentheses are a good way to force any statement to become an expression.
  exports.Parens = Parens = (function(superClass1) {
    extend1(Parens, superClass1);

    function Parens(body1) {
      this.body = body1;
    }

    Parens.prototype.children = ['body'];

    Parens.prototype.unwrap = function() {
      return this.body;
    };

    Parens.prototype.isComplex = function() {
      return this.body.isComplex();
    };

    Parens.prototype.compileNode = function(o) {
      let expr = this.body.unwrap();
      if (expr instanceof Value && expr.isAtomic()) {
        expr.front = this.front;
        return expr.compileToFragments(o);
      }
      let fragments = expr.compileToFragments(o, LEVEL_PAREN);
      let bare = o.level < LEVEL_OP && (expr instanceof Op || expr instanceof Call || (expr instanceof For && expr.returns)) && (o.level < LEVEL_COND || fragments.length <= 3);
      if (bare) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    return Parens;

  })(Base);

  //### StringWithInterpolations
  // Strings with interpolations are in fact just a variation of `Parens` with
  // string concatenation inside.
  exports.StringWithInterpolations = StringWithInterpolations = (function(superClass1) {
    // Uncomment the following line in CoffeeScript 2, to allow all interpolated
    // strings to be output using the ES2015 syntax:
    // unwrap: -> this
    extend1(StringWithInterpolations, superClass1);

    function StringWithInterpolations() {
      return StringWithInterpolations.__super__.constructor.apply(this, arguments);
    }

    StringWithInterpolations.prototype.compileNode = function(o) {
      // This method produces an interpolated string using the new ES2015 syntax,
      // which is opt-in by using tagged template literals. If this
      // StringWithInterpolations isnt inside a tagged template literal,
      // fall back to the CoffeeScript 1.x output.
      // (Remove this check in CoffeeScript 2.)
      var element, j, len1;
      if (!o.inTaggedTemplateCall) {
        return StringWithInterpolations.__super__.compileNode.apply(this, arguments);
      }
      // Assumption: expr is Value>StringLiteral or Op
      let expr = this.body.unwrap();
      let elements = [];
      expr.traverseChildren(false, function(node) {
        if (node instanceof StringLiteral) {
          elements.push(node);
          return true;
        } else if (node instanceof Parens) {
          elements.push(node);
          return false;
        }
        return true;
      });
      let fragments = [];
      fragments.push(this.makeCode('`'));
      for (j = 0, len1 = elements.length; j < len1; j++) {
        element = elements[j];
        if (element instanceof StringLiteral) {
          let value = element.value.slice(1, -1);
          // Backticks and `${` inside template literals must be escaped.
          value = value.replace(/(\\*)(`|\$\{)/g, function(match, backslashes, toBeEscaped) {
            if (backslashes.length % 2 === 0) {
              return backslashes + "\\" + toBeEscaped;
            } else {
              return match;
            }
          });
          fragments.push(this.makeCode(value));
        } else {
          fragments.push(this.makeCode('${'));
          fragments.push.apply(fragments, element.compileToFragments(o, LEVEL_PAREN));
          fragments.push(this.makeCode('}'));
        }
      }
      fragments.push(this.makeCode('`'));
      return fragments;
    };

    return StringWithInterpolations;

  })(Parens);

  //### For
  // CoffeeScript's replacement for the *for* loop is our array and object
  // comprehensions, that compile into *for* loops here. They also act as an
  // expression, able to return the result of each filtered iteration.
  //
  // Unlike Python array comprehensions, they can be multi-line, and you can pass
  // the current index of the loop as a second parameter. Unlike Ruby blocks,
  // you can map and filter in a single pass.
  exports.For = For = (function(superClass1) {
    extend1(For, superClass1);

    function For(body, source) {
      var ref3;
      this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
      this.body = Block.wrap([body]);
      this.own = !!source.own;
      this.object = !!source.object;
      this.from = !!source.from;
      if (this.from && this.index) {
        this.index.error('cannot use index with for-from');
      }
      if (this.own && !this.object) {
        source.ownTag.error("cannot use own with for-" + (this.from ? 'from' : 'in'));
      }
      if (this.object) {
        ref3 = [this.index, this.name], this.name = ref3[0], this.index = ref3[1];
      }
      if (this.index instanceof Value && !this.index.isAssignable()) {
        this.index.error('index cannot be a pattern matching expression');
      }
      this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length && !this.from;
      this.pattern = this.name instanceof Value;
      if (this.range && this.index) {
        this.index.error('indexes do not apply to range loops');
      }
      if (this.range && this.pattern) {
        this.name.error('cannot pattern match over range loops');
      }
      this.returns = false;
    }

    For.prototype.children = ['body', 'source', 'guard', 'step'];

    // Welcome to the hairiest method in all of CoffeeScript. Handles the inner
    // loop, filtering, stepping, and result saving for array, object, and range
    // comprehensions. Some of the generated code can be shared in common, and
    // some cannot.
    For.prototype.compileNode = function(o) {
      var forPartFragments, increment, ivar, last, lvar, name, namePart, ref, ref3, ref4, resultPart, returnResult, rvar, step, stepNum, stepVar, svar;
      let body = Block.wrap([this.body]);
      ref3 = body.expressions, last = ref3[ref3.length - 1];
      if ((last != null ? last.jumps() : void 0) instanceof Return) {
        this.returns = false;
      }
      let source = this.range ? this.source.base : this.source;
      let scope = o.scope;
      if (!this.pattern) {
        name = this.name && (this.name.compile(o, LEVEL_LIST));
      }
      let index = this.index && (this.index.compile(o, LEVEL_LIST));
      if (name && !this.pattern) {
        scope.find(name);
      }
      if (index && !(this.index instanceof Value)) {
        scope.find(index);
      }
      if (this.returns) {
        rvar = scope.freeVariable('results');
      }
      if (this.from) {
        if (this.pattern) {
          ivar = scope.freeVariable('x', {
            single: true
          });
        }
      } else {
        ivar = (this.object && index) || scope.freeVariable('i', {
          single: true
        });
      }
      let kvar = ((this.range || this.from) && name) || index || ivar;
      let kvarAssign = kvar !== ivar ? kvar + " = " : "";
      if (this.step && !this.range) {
        ref4 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, isComplexOrAssignable)), step = ref4[0], stepVar = ref4[1];
        if (this.step.isNumber()) {
          stepNum = Number(stepVar);
        }
      }
      if (this.pattern) {
        name = ivar;
      }
      let varPart = '';
      let guardPart = '';
      let defPart = '';
      let idt1 = this.tab + TAB;
      source.icedStatementAssertion();
      if (this.range) {
        forPartFragments = source.compileToFragments(merge(o, {
          index: ivar,
          name: name,
          step: this.step,
          isComplex: isComplexOrAssignable
        }));
      } else {
        svar = this.source.compile(o, LEVEL_LIST);
        if ((name || this.own) && !(this.source.unwrap() instanceof IdentifierLiteral)) {
          defPart += "" + this.tab + (ref = scope.freeVariable('ref')) + " = " + svar + ";\n";
          svar = ref;
        }
        if (name && !this.pattern && !this.from) {
          namePart = name + " = " + svar + "[" + kvar + "]";
        }
        if (!this.object && !this.from) {
          if (step !== stepVar) {
            defPart += "" + this.tab + step + ";\n";
          }
          let down = stepNum < 0;
          if (!(this.step && (stepNum != null) && down)) {
            lvar = scope.freeVariable('len');
          }
          let declare = "" + kvarAssign + ivar + " = 0, " + lvar + " = " + svar + ".length";
          let declareDown = "" + kvarAssign + ivar + " = " + svar + ".length - 1";
          let compare = ivar + " < " + lvar;
          let compareDown = ivar + " >= 0";
          if (this.step) {
            if (stepNum != null) {
              if (down) {
                compare = compareDown;
                declare = declareDown;
              }
            } else {
              compare = stepVar + " > 0 ? " + compare + " : " + compareDown;
              declare = "(" + stepVar + " > 0 ? (" + declare + ") : " + declareDown + ")";
            }
            increment = ivar + " += " + stepVar;
          } else {
            increment = "" + (kvar !== ivar ? "++" + ivar : ivar + "++");
          }
          forPartFragments = [this.makeCode(declare + "; " + compare + "; " + kvarAssign + increment)];
        }
      }
      if (this.returns) {
        resultPart = "" + this.tab + rvar + " = [];\n";
        returnResult = "\n" + this.tab + "return " + rvar + ";";
        body.makeReturn(rvar);
      }
      if (this.guard) {
        if (body.expressions.length > 1) {
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new StatementLiteral("continue")));
        } else {
          if (this.guard) {
            body = Block.wrap([new If(this.guard, body)]);
          }
        }
      }
      if (this.pattern) {
        body.expressions.unshift(new Assign(this.name, this.from ? new IdentifierLiteral(kvar) : new Literal(svar + "[" + kvar + "]")));
      }
      let defPartFragments = [].concat(this.makeCode(defPart), this.pluckDirectCall(o, body));
      if (namePart) {
        varPart = "\n" + idt1 + namePart + ";";
      }
      if (this.object) {
        forPartFragments = [this.makeCode(kvar + " in " + svar)];
        if (this.own) {
          guardPart = "\n" + idt1 + "if (!" + (utility('hasProp', o)) + ".call(" + svar + ", " + kvar + ")) continue;";
        }
      } else if (this.from) {
        forPartFragments = [this.makeCode(kvar + " of " + svar)];
      }
      let bodyFragments = body.compileToFragments(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      if (bodyFragments && bodyFragments.length > 0) {
        bodyFragments = [].concat(this.makeCode("\n"), bodyFragments, this.makeCode("\n"));
      }
      return [].concat(defPartFragments, this.makeCode("" + (resultPart || '') + this.tab + "for ("), forPartFragments, this.makeCode(") {" + guardPart + varPart), bodyFragments, this.makeCode(this.tab + "}" + (returnResult || '')));
    };

    For.prototype.pluckDirectCall = function(o, body) {
      var expr, idx, j, len1, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      let defs = [];
      ref3 = body.expressions;
      for (idx = j = 0, len1 = ref3.length; j < len1; idx = ++j) {
        expr = ref3[idx];
        expr = expr.unwrapAll();
        if (!(expr instanceof Call)) {
          continue;
        }
        let val = (ref4 = expr.variable) != null ? ref4.unwrapAll() : void 0;
        if (!((val instanceof Code) || (val instanceof Value && ((ref5 = val.base) != null ? ref5.unwrapAll() : void 0) instanceof Code && val.properties.length === 1 && ((ref6 = (ref7 = val.properties[0].name) != null ? ref7.value : void 0) === 'call' || ref6 === 'apply')))) {
          continue;
        }
        let fn = ((ref8 = val.base) != null ? ref8.unwrapAll() : void 0) || val;
        let ref = new IdentifierLiteral(o.scope.freeVariable('fn'));
        let base = new Value(ref);
        if (val.base) {
          ref9 = [base, val], val.base = ref9[0], base = ref9[1];
        }
        body.expressions[idx] = new Call(base, expr.args);
        defs = defs.concat(this.makeCode(this.tab), new Assign(ref, fn).compileToFragments(o, LEVEL_TOP), this.makeCode(';\n'));
      }
      return defs;
    };

    return For;

  })(While);

  //### Switch
  // A JavaScript *switch* statement. Converts into a returnable expression on-demand.
  exports.Switch = Switch = (function(superClass1) {
    extend1(Switch, superClass1);

    function Switch(subject, cases, otherwise) {
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
    }

    Switch.prototype.children = ['subject', 'cases', 'otherwise'];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = function(o) {
      var block, conds, j, jumpNode, len1, ref3, ref4, ref5;
      if (o == null) {
        o = {
          block: true
        };
      }
      ref3 = this.cases;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        ref4 = ref3[j], conds = ref4[0], block = ref4[1];
        if (jumpNode = block.jumps(o)) {
          return jumpNode;
        }
      }
      return (ref5 = this.otherwise) != null ? ref5.jumps(o) : void 0;
    };

    Switch.prototype.makeReturn = function(res) {
      var j, len1, pair, ref3, ref4;
      ref3 = this.cases;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        pair = ref3[j];
        pair[1].makeReturn(res);
      }
      if (res) {
        this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
      }
      if ((ref4 = this.otherwise) != null) {
        ref4.makeReturn(res);
      }
      return this;
    };

    Switch.prototype.compileNode = function(o) {
      var block, body, cond, conditions, i, j, k, len1, len2, ref3, ref4, ref5;
      if (this.subject) {
        this.subject.icedStatementAssertion();
      }
      let idt1 = o.indent + TAB;
      let idt2 = o.indent = idt1 + TAB;
      let fragments = [].concat(this.makeCode(this.tab + "switch ("), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false")), this.makeCode(") {\n"));
      ref3 = this.cases;
      for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) {
        ref4 = ref3[i], conditions = ref4[0], block = ref4[1];
        ref5 = flatten([conditions]);
        for (k = 0, len2 = ref5.length; k < len2; k++) {
          cond = ref5[k];
          if (!this.subject) {
            cond = cond.invert();
          }
          fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
        }
        if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
          fragments = fragments.concat(body, this.makeCode('\n'));
        }
        if (i === this.cases.length - 1 && !this.otherwise) {
          break;
        }
        let expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) {
          continue;
        }
        fragments.push(cond.makeCode(idt2 + 'break;\n'));
      }
      if (this.otherwise && this.otherwise.expressions.length) {
        fragments.push.apply(fragments, [this.makeCode(idt1 + "default:\n")].concat(slice.call(this.otherwise.compileToFragments(o, LEVEL_TOP)), [this.makeCode("\n")]));
      }
      fragments.push(this.makeCode(this.tab + '}'));
      return fragments;
    };

    return Switch;

  })(Base);

  //### If
  // *If/else* statements. Acts as an expression by pushing down requested returns
  // to the last line of each clause.
  //
  // Single-expression **Ifs** are compiled into conditional operators if possible,
  // because ternaries are already proper expressions, and don't need conversion.
  exports.If = If = (function(superClass1) {
    extend1(If, superClass1);

    function If(condition, body1, options) {
      this.body = body1;
      if (options == null) {
        options = {};
      }
      this.condition = options.type === 'unless' ? condition.invert() : condition;
      this.elseBody = null;
      this.isChain = false;
      this.soak = options.soak;
    }

    If.prototype.children = ['condition', 'body', 'elseBody'];

    If.prototype.bodyNode = function() {
      var ref3;
      return (ref3 = this.body) != null ? ref3.unwrap() : void 0;
    };

    If.prototype.elseBodyNode = function() {
      var ref3;
      return (ref3 = this.elseBody) != null ? ref3.unwrap() : void 0;
    };

    // Rewrite a chain of **Ifs** to add a default case as the final *else*.
    If.prototype.addElse = function(elseBody) {
      if (this.isChain) {
        this.elseBodyNode().addElse(elseBody);
      } else {
        this.isChain = elseBody instanceof If;
        this.elseBody = this.ensureBlock(elseBody);
        this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
      }
      return this;
    };

    // The **If** only compiles into a statement if either of its bodies needs
    // to be a statement. Otherwise a conditional operator is safe.
    If.prototype.isStatement = function(o) {
      var ref3;
      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref3 = this.elseBodyNode()) != null ? ref3.isStatement(o) : void 0);
    };

    If.prototype.jumps = function(o) {
      var ref3;
      return this.body.jumps(o) || ((ref3 = this.elseBody) != null ? ref3.jumps(o) : void 0);
    };

    If.prototype.compileNode = function(o) {
      this.condition.icedStatementAssertion();
      if (this.isStatement(o)) {
        return this.compileStatement(o);
      } else {
        return this.compileExpression(o);
      }
    };

    If.prototype.makeReturn = function(res) {
      if (res) {
        this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
      }
      this.body && (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
    };

    If.prototype.ensureBlock = function(node) {
      if (node instanceof Block) {
        return node;
      } else {
        return new Block([node]);
      }
    };

    // Compile the `If` as a regular *if-else* statement. Flattened chains
    // force inner *else* bodies into statement form.
    If.prototype.compileStatement = function(o) {
      let child = del(o, 'chainChild');
      let exeq = del(o, 'isExistentialEquals');
      if (exeq) {
        return new If(this.condition.invert(), this.elseBodyNode(), {
          type: 'if'
        }).compileToFragments(o);
      }
      let indent = o.indent + TAB;
      let cond = this.condition.compileToFragments(o, LEVEL_PAREN);
      let body = this.ensureBlock(this.body).compileToFragments(merge(o, {
        indent: indent
      }));
      let ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode("\n" + this.tab + "}"));
      if (!child) {
        ifPart.unshift(this.makeCode(this.tab));
      }
      if (!this.elseBody) {
        return ifPart;
      }
      let answer = ifPart.concat(this.makeCode(' else '));
      if (this.isChain) {
        o.chainChild = true;
        answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
      } else {
        answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {
          indent: indent
        }), LEVEL_TOP), this.makeCode("\n" + this.tab + "}"));
      }
      return answer;
    };

    // Compile the `If` as a conditional operator.
    If.prototype.compileExpression = function(o) {
      let cond = this.condition.compileToFragments(o, LEVEL_COND);
      let body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
      let alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
      let fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
      if (o.level >= LEVEL_COND) {
        return this.wrapInBraces(fragments);
      } else {
        return fragments;
      }
    };

    If.prototype.unfoldSoak = function() {
      return this.soak && this;
    };

    return If;

  })(Base);

  //### Begin Iced Additions
  //### Slot
  //
  //  A Slot is an argument passed to `defer(..)`.  It's a bit different
  //  from a normal parameters, since it's trying to implement pass-by-reference.
  //  It's used only in concert with the Defer class.  Splats and Values
  //  can be converted to slots with the `icedToSlot` method.
  //
  exports.Slot = Slot = (function(superClass1) {
    extend1(Slot, superClass1);

    function Slot(index, value, suffix, splat) {
      Slot.__super__.constructor.call(this);
      this.index = index;
      this.value = value;
      this.suffix = suffix;
      this.splat = splat;
      this.access = null;
    }

    Slot.prototype.addAccess = function(a) {
      this.access = a;
      return this;
    };

    Slot.prototype.children = ['value', 'suffix'];

    return Slot;

  })(Base);

  //### Defer
  exports.Defer = Defer = (function(superClass1) {
    extend1(Defer, superClass1);

    function Defer(args, lineno) {
      var a, i;
      this.lineno = lineno;
      Defer.__super__.constructor.call(this);
      this.slots = flatten((function() {
        var j, len1, results;
        results = [];
        for (i = j = 0, len1 = args.length; j < len1; i = ++j) {
          a = args[i];
          results.push(a.icedToSlot(i));
        }
        return results;
      })());
      this.params = [];
      this.vars = [];
      this.custom = false;
    }

    Defer.prototype.children = ['slots'];

    // Most deferrals are not "custom", meaning they assume
    // __iced_deferrals as a `this` object.  Rendezvous and others
    // are custom, since there is an object that's acting as `this`
    Defer.prototype.setCustom = function() {
      this.custom = true;
      return this;
    };

    // Count hidden parameters up from 1.  Make a note of which parameter
    // we passed out.  Return a copy of that parameter, in case we mutate
    // it later before we output it.
    Defer.prototype.newParam = function() {
      let l = iced["const"].slot + "_" + (this.params.length + 1);
      this.params.push(new Param(new Literal(l)));
      return new Value(new Literal(l));
    };

    //
    // makeAssignFn
    //   - Implement C++-style pass-by-reference in Coffee
    //
    // the 'assign_fn' returned by here will set all parameters to defer()
    // to have the appropriate values after the defer is fulfilled. The
    // four cases to consider are listed in the following call:
    //
    //     defer(x, a.b, c.d[i], rest...)
    //
    // Case 1 -- defer(x) --  Regular assignment to a local variable
    // Case 2 -- defer(a.b) --  Assignment to an object; must capture
    //    object when defer() is called
    // Case 3 -- defer(c.d[i]) --  Assignment to an array slot; must capture
    //   array and slot index with defer() is called
    // Case 4 -- defer(rest...) -- rest is an array, assign it to all
    //   leftover arguments.
    //
    Defer.prototype.makeAssignFn = function(o) {
      var assign, call, j, len1, prop, ref3, s, slot;
      if (this.slots.length === 0) {
        return null;
      }
      let assignments = [];
      let args = [];
      let i = 0;
      ref3 = this.slots;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        s = ref3[j];
        i = s.index;
        let a = new Value(new IdentifierLiteral("arguments"));
        let i_lit = new Value(new IdentifierLiteral(i));
        if (s.splat) {
          // case 4
          let func = new Value(new IdentifierLiteral(utility('slice', o)));
          func.add(new Access(new PropertyName('call')));
          call = new Call(func, [a, i_lit]);
          slot = s.value;
          this.vars.push(slot);
          assign = new Assign(slot, call);
        } else {
          a.add(new Index(i_lit));
          if (s.access) {
            a.add(s.access);
          }
          if (!s.suffix) {
            // case 1
            slot = s.value;
            this.vars.push(slot);
          } else {
            args.push(s.value);
            slot = this.newParam();
            if (s.suffix instanceof Index) {
              // case 3
              prop = new Index(this.newParam());
              args.push(s.suffix.index);
            } else {
              // case 2
              prop = s.suffix;
            }
            slot.add(prop);
          }
          assign = new Assign(slot, a);
        }
        assignments.push(assign);
      }
      let block = new Block(assignments);
      let inner_fn = new Code([], block, 'icedgen');
      let outer_block = new Block([new Return(inner_fn)]);
      let outer_fn = new Code(this.params, outer_block, 'icedgen');
      return call = new Call(outer_fn, args);
    };

    Defer.prototype.transform = function(o) {
      // In the custom case, there's a foo.defer, and we're going to
      // use the `foo` as the this object.  Otherwise, we'll
      // use the `__iced_deferrals` in the current scope as the `this` object
      var assign_fn, fn, parent;
      if (this.custom) {
        fn = new PropertyName(iced["const"].defer_method);
      } else if ((parent = this.icedParentAwait) != null) {
        fn = parent.icedDeferrals.copy();
        // now, fn is '__iced_deferrals.defer'
        fn.add(new Access(new PropertyName(iced["const"].defer_method)));
      } else {
        this.error("defer() without parent await or Rendezvous");
      }
      // There is one argument to Deferrals.defer(), which is a dictionary.
      // The dictionary currently only has one slot: assign_fn, which
      //   indicates a function.
      // More slots will be needed if we ever want to keep track of iced-aware
      //   stack traces.
      let assignments = [];
      if ((assign_fn = this.makeAssignFn(o))) {
        assignments.push(new Assign(new Value(new Literal(iced["const"].assign_fn)), assign_fn, "object"));
      }
      let ln_lhs = new Value(new IdentifierLiteral(iced["const"].lineno));
      let ln_rhs = new Value(new NumberLiteral(this.lineno));
      let ln_assign = new Assign(ln_lhs, ln_rhs, "object");
      assignments.push(ln_assign);
      if (this.custom) {
        let context_lhs = new Value(new IdentifierLiteral(iced["const"].context));
        let context_rhs = new Value(new IdentifierLiteral(iced["const"].deferrals));
        let context_assign = new Assign(context_lhs, context_rhs, "object");
        assignments.push(context_assign);
      }
      o = new Obj(assignments);
      // Return the final call
      return new Call(fn, [new Value(o)]);
    };

    Defer.prototype.compileNode = function(o) {
      var j, len1, ref3, v;
      let call = this.transform(o);
      ref3 = this.vars;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        v = ref3[j];
        let name = v.compile(o, LEVEL_LIST);
        let scope = o.scope;
        scope.find(name, 'var');
      }
      return call.compileNode(o);
    };

    Defer.prototype.icedWalkAst = function(o) {
      Defer.__super__.icedWalkAst.call(this, o);
      o.deferInFile = true;
      return this.icedParentAwait = o.await;
    };

    return Defer;

  })(Base);

  let quote_funcname_for_debug = function(n) {
    // Remove all single and double quotes to make the emitted funcname safe
    // See issue #144. Thanks to @sidthekidder for this patch.
    return '"' + n.replace(/["']/g, '') + '"';
  };

  let quote_path_for_emission = function(n) {
    // Replace '\' with '\\' to make the emitted code safe for Windows
    // paths.  See Issue #84. Thanks to @Deathspike for this patch
    return '"' + n.replace(/\\/g, '\\\\') + '"';
  };

  let require_top_dir = function() {
    // See #139, need to use window-safe pathname quoting for requring
    // the top current directory. Windows!
    return quote_path_for_emission(pathmod.join(__dirname, "..", ".."));
  };

  //### Await
  exports.Await = Await = (function(superClass1) {
    extend1(Await, superClass1);

    function Await(body1) {
      this.body = body1;
      Await.__super__.constructor.call(this);
    }

    Await.prototype.transform = function(o) {
      var lhs, n, ref3, ref4;
      let body = this.body;
      let name = o.scope.freeVariable(iced["const"].deferrals);
      this.icedDeferrals = lhs = new Value(new IdentifierLiteral(name));
      let cls = new Value(new IdentifierLiteral(iced["const"].ns));
      cls.add(new Access(new PropertyName(iced["const"].Deferrals)));
      let assignments = [];
      if (n = (ref3 = this.icedParentFunc) != null ? ref3.icedPassedDeferral : void 0) {
        let cb_lhs = new Value(new Literal(iced["const"].parent));
        let cb_rhs = n;
        let cb_assignment = new Assign(cb_lhs, cb_rhs, "object");
        assignments.push(cb_assignment);
      }
      if (n = (ref4 = this.icedParentFunc) != null ? ref4.icedTraceName : void 0) {
        let func_lhs = new Value(new Literal(iced["const"].funcname));
        let func_rhs = new Value(new Literal(quote_funcname_for_debug(n)));
        let func_assignment = new Assign(func_lhs, func_rhs, "object");
        assignments.push(func_assignment);
      }
      if (o.filename) {
        let fn_lhs = new Value(new Literal(iced["const"].filename));
        let fn_rhs = new Value(new Literal(quote_path_for_emission(o.filename)));
        let fn_assignment = new Assign(fn_lhs, fn_rhs, "object");
        assignments.push(fn_assignment);
      }
      // { parent : __iced_passed_deferrals, funcname : foo }
      let trace = new Obj(assignments, true);
      // var __iced_deferrals_1 = new iced.Deferrals(__it, { parent : __iced_passed_deferrals, funcname : foo })
      let call = new Call(cls, [this.icedParentFunc.icedIterator, trace]);
      let rhs = new Op("new", call);
      let assign = new Assign(lhs, rhs);
      body.unshift(assign);
      // if (__iced_deferrals_1.await_exit()) { yield; }
      let meth = lhs.copy().add(new Access(new PropertyName(iced["const"].await_exit)));
      body.push(new If(new Call(meth, []), new Block([new Literal('yield')])));
      return body;
    };

    Await.prototype.children = ['body'];

    Await.prototype.isStatement = YES;

    Await.prototype.makeReturn = THIS;

    Await.prototype.compileNode = function(o) {
      return this.transform(o).compileNode(o);
    };

    Await.prototype.icedWalkAst = function(o) {
      if (o.await != null) {
        this.error("Can't have nested await blocks");
      }
      o.await = this;
      Await.__super__.icedWalkAst.call(this, o);
      o.await = null;
      // Pass these messages back up
      o.awaitInFile = o.awaitInFunc = true;
      return this.icedParentFunc = o.func;
    };

    return Await;

  })(Base);

  //### IcedRuntime
  //
  // By default, the iced libraries are require'd via nodejs' require.
  // You can change this behavior on the command line:
  //
  //    -I inline --- inlines a simplified runtime to the output file
  //    -I node   --- force node.js inclusion
  //    -I window --- attach the inlined runtime to the window.* object
  //    -I none   --- no inclusion, do it yourself...
  //
  IcedRuntime = (function(superClass1) {
    extend1(IcedRuntime, superClass1);

    function IcedRuntime(foundDefer, foundAwait) {
      this.foundDefer = foundDefer;
      this.foundAwait = foundAwait;
      IcedRuntime.__super__.constructor.call(this);
    }

    IcedRuntime.prototype.compileNode = function(o, level) {
      this.expressions = [];
      let v = o.runtime ? o.runtime : o.bare ? "none" : this.foundDefer ? "node" : "none";
      if (o.runtime && !this.foundDefer && !o.runforce) {
        v = "none";
      }
      // 'inline' and 'window' runtimes are emitted with makeCode and
      // include inline-runtime-str that is generated by cake.
      switch (v) {
        case "inline":
          return this.makeCode(this.inlineRuntime('var iced'));
        case "window":
          return this.makeCode(this.inlineRuntime('window.iced'));
      }
      let inc = null;
      inc = (function() {
        switch (v) {
          case "node":
          case "browserify":
          case "interp":
            // Emit a `require` call.
            let interp = v === "interp";
            let qmodname = interp ? require_top_dir() : "'iced-runtime-3'";
            let accessname = iced["const"].ns;
            let file = new Literal(qmodname);
            let access = new Access(new Literal(accessname));
            let req = new Value(new Literal("require"));
            let call = new Call(req, [file]);
            let callv = new Value(call);
            if (interp) {
              callv.add(access);
            }
            let ns = new Value(new IdentifierLiteral(iced["const"].ns));
            return new Assign(ns, callv);
          case "none":
            return null;
          default:
            return this.error("unexpected flag IcedRuntime " + v);
        }
      }).call(this);
      if (inc) {
        this.push(inc);
      }
      if (this.isEmpty()) {
        return [];
      } else {
        return IcedRuntime.__super__.compileNode.call(this, o);
      }
    };

    IcedRuntime.prototype.inlineRuntime = function(lefthand) {
      return lefthand + " = " + (require('./inline-runtime-str')) + ";\n";
    };

    return IcedRuntime;

  })(Block);

  //### End Iced Additions
  // Constants
  // ---------
  let UTILITIES =  /* Correctly set up a prototype chain for inheritance, including a reference */  /* to the superclass for `super()` calls, and copies of any static properties. */ {
    extend: function(o) {
      return "function(child, parent) { for (var key in parent) { if (" + (utility('hasProp', o)) + ".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }";
    },
    // Create a function bound to the current value of "this".
    bind: function() {
      return 'function(fn, me){ return function(){ return fn.apply(me, arguments); }; }';
    },
    // Discover if an item is in an array.
    indexOf: function() {
      return "[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }";
    },
    modulo: function() {
      return "function(a, b) { return (+a % (b = +b) + b) % b; }";
    },
    // Shortcuts to speed up the lookup time for native functions.
    hasProp: function() {
      return '{}.hasOwnProperty';
    },
    slice: function() {
      return '[].slice';
    }
  };

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  let LEVEL_TOP = 1;

  // ...;
  let LEVEL_PAREN = 2;

  // (...)
  let LEVEL_LIST = 3;

  // [...]
  let LEVEL_COND = 4;

  // ... ? x : y
  let LEVEL_OP = 5;

  // !...
  let LEVEL_ACCESS = 6;

  // ...[0]
  // Tabs are two spaces for pretty printing.
  let TAB = '  ';

  let SIMPLENUM = /^[+-]?\d+$/;

  let IDENTIFIER_STR = "[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*";

  let METHOD_DEF = RegExp("^(" + IDENTIFIER_STR + ")(\\.prototype)?(?:\\.(" + IDENTIFIER_STR + ")|\\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|'(?:[^\\\\'\\r\\n]|\\\\.)*')\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\])$");

  // Helper Functions
  // ----------------
  // Helper for ensuring that utility functions are assigned at the top level.
  let utility = function(name, o) {
    var root;
    root = o.scope.root;
    if (name in root.utilities) {
      return root.utilities[name];
    } else {
      let ref = root.freeVariable(name);
      root.assign(ref, UTILITIES[name](o));
      return root.utilities[name] = ref;
    }
  };

  let multident = function(code, tab) {
    code = code.replace(/\n/g, '$&' + tab);
    return code.replace(/\s+$/, '');
  };

  let isLiteralArguments = function(node) {
    return node instanceof IdentifierLiteral && node.value === 'arguments';
  };

  let isLiteralThis = function(node) {
    return node instanceof ThisLiteral || (node instanceof Code && node.bound) || node instanceof SuperCall;
  };

  let isComplexOrAssignable = function(node) {
    return node.isComplex() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
  };

  // Unfold a node's child if soak, then tuck the node under created `If`
  let unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

}).call(this);
